
* 第二章 Scala 入门
** 定义变量
   val：一旦初始化不能被重新赋值。
   var

   Scala 并不是在变量名之前给出类型，而是在变量名之后，变量名和类型之间使用分号（:）隔开。
** 定义函数
   #+begin_src scala
     def max(x: Int, y: Int): Int = {
       if (x > y)
         x
       else
         y
     }
     max(1,2)
   #+end_src

   #+RESULTS:
   : max: (x: Int, y: Int)Int
   : res6: Int = 2
   
   函数体之前的等号也有特别的含义，表示在函数式的世界观里，函数定义的是一个可以获取到结果值的表达式。

   如果函数是递归的，必须显示地给出函数的结果类型。

   如果函数只有一条语句，也可以选择不使用花括号。

** 用 while 做循环；用 if 做判断
   #+begin_src scala
     var i = 0
     val l = List("scala", "is", "fun")
     while (i < l.length){
       println(l(i))
       i += 1
     }
   #+end_src
   
   #+RESULTS:
   : i: Int = 0
   : l: List[String] = List(scala, is, fun)
   : scala
   : is
   : fun
   
   Java 中的 i++ 和 ++i 在 Scala 中并不工作

   Scala 中 while 或 if 语句中的 boolean 表达式必须放在圆括号里。如果 if 代码块只有单个语句，可以选择不写花括号。这点和 Java 是一样的。

   这并不是最佳的 scala 风格。
   
** 使用 foreach 和 for 遍历
   当你写下 while 循环时，实际上是在以指令式（imperative）的风格编程。指令时风格也是类似 Java，C++，C 这样的语言通常的风格，依次给出执行指令，通过循环来遍历，而且还经常变更被不同函数共享的状态。Scala 允许以指令式风格编程，不过随着你对 Scala 的了解日益加深，你应该更倾向于使用更加函数式（functional）的风格。

   函数式编程语言的主要特征之一就是函数是一等的语法单元。例如：
   #+begin_src scala
     val l = List("Concise", "is", "nice")
     l.foreach(arg => println(arg))
   #+end_src

   #+RESULTS:
   : l: List[String] = List(Concise, is, nice)
   : Concise
   : is
   : nice

   foreach 方法传入的是一个函数字面量（function literal）。

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/函数字面量语法.png]]
   

   如果函数字面量只是一个可以接收单个参数的语句，可以不必给出参数名和参数本身。这个简写规则用到的特性叫作部分应用函数（partially applied function），在 8.6 节会有详细介绍。
   #+begin_src scala
     val l = List("Concise", "is", "nice")
     l.foreach(println)
   #+end_src

   #+RESULTS:
   : l: List[String] = List(Concise, is, nice)
   : Concise
   : is
   : nice


   #+begin_src scala
     val l = List("for", "arg", "in", "args")
     for(arg <- l)
       println(arg)
   #+end_src

   #+RESULTS:
   : l: List[String] = List(for, arg, in, args)
   : for
   : arg
   : in
   : args
   
   在 <- 符合左边的 arg 是一个 val 变量。对于 args 中的每一个元素，一个新的名为 arg 的 val 会被创建出来。


* 第三章 Scala 入门（续）
** 用类型参数化（parameterize）数组
   参数化的意思是，在创建实例时对实例做“配置”。比如使用 new 来实例化对象时，可以用值和类型来对其进行参数化。

   注意，当你使用类型和值来参数化一个实例时，先是方括号包起来的类型（参数），然后才是用圆括号包起来的值（参数）。

   类型参数（方括号包起来的类型名称）是该实例类型的一部分，但值参数（圆括号包起来的值）并不是。
   
   #+begin_src scala
     val greetStrings = new Array[String](3)
     greetStrings(0) = "Hello"
     greetStrings(1) = ", "
     greetStrings(2) = "world!\n"
     for(i <- 0 to 2)
       print(greetStrings(i))

     // 也可以显示的给出 greetStrings 的类型
     val greetStrings: Array[String] = new Array[String](3)
   #+end_src

   #+RESULTS:
   : greetStrings: Array[String] = Array(null, null, null)
   : Hello, world!
   : greetStrings: Array[String] = Array(null, null, null)

   这个例子展示了 Scala 关于 val 的一个重要概念。当你用 val 定义一个变量时，变量本身不能被重新赋值，但是它指向的那个对象是可能发生改变的。数组本身是可变的。

   for 表达式的第一行展示了 Scala 的另一个通行规则：如果一个方法只接收一个参数，在调用它的时候，可以不使用英文句点或圆括号。例如：0 to 2 会被转换为 (0).to(2)

   Scala 从技术上将并没有操作符重载（operator overloading），因为它实际上并没有传统意义上的操作符。类似 + ，-，*，/ 这样的字符可以被用作方法名。例如：1 + 2 是 (1).+(2)

   另外一个重要理念是为什么 Scala 用圆括号（而不是方括号）来访问数组。跟 Java 比起来 Scala 特例更少。数组不过是类的实例，这一点跟其他 Scala 实例没有本质区别。当你用一组圆括号将一个或多个值包装起来，并将其应用（apply）到某个对象时，Scala 会将这段代码转换成对这个对象的一个名为 apply 的方法的调用。访问数组的一个元素就是一个简单的方法调用。当然，这仅对在对象的类型实际上定义了 apply 方法是才能编译通过。因此，这并不是一个特例，而是一个通行规则。

   同理，当我们尝试对通过圆括号应用了一个或多个参数的变量进行赋值时，编译器会将代码转换成对 update 方法的调用。
   
   #+begin_src scala

// Scala 创建并初始化数组的推荐做法
val numName = Array("zero", "one", "two")

   #+end_src

   #+RESULTS:
   : numName: Array[String] = Array(zero, one, two)

   这个例子，实际上是调用了一个名为 apply 的工厂方法，这个方法创建并返回了新的数组。该方法定义在 Array 的伴生对象（companion object）中。
** 使用列表
   函数式编程的重要概念之一是方法不能有副作用。这样做的好处是方法不再相互纠缠在一起，因此变得更可靠，更易复用。另一个好处（作为静态类型的编程语言）是类型检查器会检查方法的入参和出参，因此逻辑错误通常都是以类型错误的形式出现。将这个函数式的哲学应用到对象的世界意味着让对象不可变。

   Scala 的 List 是不可变的。
   #+begin_src scala
     val twoThree = List(2, 3)
     val oneTwoThree = 1 :: twoThree
     println(oneTwoThree)
   #+end_src

   #+RESULTS:
   : twoThree: List[Int] = List(2, 3)
   : oneTwoThree: List[Int] = List(1, 2, 3)
   : List(1, 2, 3)

   注意 :: 是右操作元（right operand，即 twoThree 这个列表的方法）。背后的规则是，如果一个方法被用到操作符表示法（operator notation）中时，调用默认发生在左操作元（left operand），除非方法名以冒号（:）结尾。

   空列表的快捷表示为 Nil。

   为什么不在列表末尾追加元素？List 类提供了追加操作（:+），但是很少被使用，因为往列表末尾追加元素的操作所需要的时间随列表的大小线性增加，而使用 :: 在列表前面添加元素只需要常量时间。如果想通过追加元素的方式高效地构建列表，可以依次在头部添加完成后，在调用 reverse。也可以使用 ListBuffer，这是个可变列表，支持追加操作，完成后调用 toList 即可。
   #+begin_src scala
     // 列表的一些常用方法
     List()
     Nil
     List("Cool", "tools", "rule")
     val thrill = "Will" :: "fill" :: "util" :: Nil
     List("a", "b") ::: List("c", "d")
     thrill(2)
     thrill.count(s => s.length == 4)
     // 去掉头两个元素
     thrill.drop(2)
     // 去掉末尾两个元素
     thrill.dropRight(2)
     thrill.exists(s => s == "util")
     thrill.filter(s => s.length == 4)
     thrill.forall(s => s.endsWith("l"))
     thrill.foreach(s => println(s))
     thrill.foreach(println)
     // 返回头一个元素
     thrill.head
     // 返回除最后一个元素以外的其他元素组成的列表。
     thrill.init
     thrill.isEmpty
     // 返回最后一个元素
     thrill.last
     thrill.length
     thrill.map(s => s + "y")
     thrill.mkString(", ")
     thrill.filterNot(s => s.length == 4)
     thrill.reverse
     // thrill.sort((s,t) => s.charAt(0).toLower < t.charAt(0).toLower)
     // 返回除头一个元素以外的其它元素组成的列表
     thrill.tail
   #+end_src

   #+RESULTS:
   #+begin_example
   res128: List[Nothing] = List()
   res129: scala.collection.immutable.Nil.type = List()
   res130: List[String] = List(Cool, tools, rule)
   thrill: List[String] = List(Will, fill, util)
   res131: List[String] = List(a, b, c, d)
   res132: String = util
   res133: Int = 3
   res134: List[String] = List(util)
   res135: List[String] = List(Will)
   res136: Boolean = true
   res137: List[String] = List(Will, fill, util)
   res138: Boolean = true
   Will
   fill
   util
   Will
   fill
   util
   res141: String = Will
   res142: List[String] = List(Will, fill)
   res143: Boolean = false
   res144: String = util
   res145: Int = 3
   res146: List[String] = List(Willy, filly, utily)
   res147: String = Will, fill, util
   res148: List[String] = List()
   res149: List[String] = List(util, fill, Will)
   res150: List[String] = List(fill, util)
   #+end_example

** 使用元组
   元组也是不可变的，元组可以容纳不同类型。一旦实例好一个元组，可以使用英文句点，下划线和从 1 开始的序号来访问每一个元素。

   #+begin_src scala
     val pair = (99, "Luftballons")
     println(pair._1)
     println(pair._2)
   #+end_src

   #+RESULTS:
   : pair: (Int, String) = (99,Luftballons)
   : 99
   : Luftballons

   为什么不能像访问列表元素那样访问元组元素。背后的原因是列表的 apply 方法永远只返回同一种类型，但元组里的元素可以是不同类型的。_1 可能是一种类型，_2 可能是另一种类型。目前 Scala 标准库只支持到 Tuple22 （即包含 22 个元素的元组）。

** 使用集和映射

   集合类库特意对可变和不可变的集合进行了区分。默认创建一个不可变集。如果需要可变的，要做一次 import。

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/set的类继承关系.png]]

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/map的类继承关系.png]]

   #+begin_src scala
     var jetSet = Set("Boeing", "Airbus")
     jetSet += "Lear"
     println(jetSet.contains("Cessna"))
   #+end_src

   #+RESULTS:
   : jetSet: scala.collection.immutable.Set[String] = Set(Boeing, Airbus)
   : false

   注意第二行，"jetSet += "Lear"" 本质上是 jetSet = jetSet + "Lear" 的简写。

   "+" 方法会创建一个并返回一个包含新元素的 Set。所以 jetSet 定义时要使用 var，因为重新进行了赋值。
    
   #+begin_src scala
     import scala.collection.mutable
     val movieSet = mutable.Set("Hitch", "Poltergeist")
     movieSet += "Shrek"
     println(movieSet)
   #+end_src

   #+RESULTS:
   : import scala.collection.mutable
   : movieSet: scala.collection.mutable.Set[String] = Set(Poltergeist, Hitch)
   : res9: movieSet.type = Set(Poltergeist, Shrek, Hitch)
   : Set(Poltergeist, Shrek, Hitch)

   第三行的 += 实际上是定义在可变 Set 上的方法。

   #+begin_src scala
     val romanNumeral = Map(1 -> "I", 2 -> "II", 3 -> "III", 4 -> "IV", 5 -> "V")
     println(romanNumeral)
   #+end_src

   #+RESULTS:
   : romanNumeral: scala.collection.immutable.Map[Int,String] = Map(5 -> V, 1 -> I, 2 -> II, 3 -> III, 4 -> IV)
   : Map(5 -> V, 1 -> I, 2 -> II, 3 -> III, 4 -> IV)

   -> 也是方法
   
   #+begin_src scala
     import scala.collection.mutable

     val treasureMap = mutable.Map[Int, String]()
     treasureMap += (1 -> "Go to island.")
     treasureMap += (2 -> "Find big X on ground.")
     treasureMap += (3 -> "Dig.")
     println(treasureMap(2))
   #+end_src

   #+RESULTS:
   : import scala.collection.mutable
   : treasureMap: scala.collection.mutable.Map[Int,String] = Map()
   : res14: treasureMap.type = Map(1 -> Go to island.)
   : res15: treasureMap.type = Map(2 -> Find big X on ground., 1 -> Go to island.)
   : res16: treasureMap.type = Map(2 -> Find big X on ground., 1 -> Go to island., 3 -> Dig.)
   : Find big X on ground.

** 识别函数式编程风格
   scala 更偏向于使用 val 。
   
   #+begin_src scala
     def printArgs(args: Array[String]): Unit = {
       var i = 0
       while(i < args.length) {
         println(args(i))
         i += 1
       }
     }

     // 去掉 var
     def printArgs(args: Array[String]): Unit = {
       for(arg <- args)
         println(arg)
     }

     // 或者
     def printArgs(args: Array[String]): Unit = {
       args.foreach(println)
     }

   #+end_src

   #+RESULTS:
   : printArgs: (args: Array[String])Unit
   : printArgs: (args: Array[String])Unit
   : printArgs: (args: Array[String])Unit

   重构后的方法依然不是 ”纯“ 的函数式代码，因为它有副作用（本例中它的副作用是像标准输出流打印）。带有副作用的函数的标志性特征是结果类型为 Unit。如果一个函数不返回任何有意义的值，也就是 Unit 这样的结果类型所表达的意思，那么这个函数存在于世上唯一的意义就是产生某种副作用。
   
   #+begin_src scala
     def formatArgs(args: Array[String]) = args.mkString("\n")
   #+end_src

   #+RESULTS:
   : formatArgs: (args: Array[String])String

   scala 是指令式/函数式混合（hybrid）编程语言，你会发现有些场景下对于要解决的问题而言指令式更为合适，这个时候不要犹豫，使用指令式的风格就好。

* 第四章 类和对象
** 类，字段和方法
   #+begin_src scala
     class ChecksumAccumulator{
       // 这里是类定义
     }
   #+end_src
   在类定义中，你会填入字段（field）和方法（method），这些被统称为成员（member）。字段保留了对象的状态，或者说数据，而方法用这些数据来对对象执行计算。
   
   字段又叫做实例变量（instance variable），因为每个实例都有自己的变量。

   追求健壮性的一个重要手段是确保对象的状态（它的实例变量的值）在其整个声明周期都是有效的。首先是通过将字段标记为私有（private）来防止外部直接访问字段。在 Scala 中，使得成员允许公共访问（public）的方式是不再成员前面显示地给出任何访问修饰符。

   Scala 方法参数的一个重要特征是它们都是 val 而不是 var。所有方法都是，不光是类中的方法。

   在没有任何显示的 return 语句时，Scala 方法返回的是该方法计算出的最后一个（表达式的）值。实际上推荐的风格是避免使用任何显示的 return 语句，尤其是多个 return 语句。与此相反，尽量将每个方法当作是一个最终交出某个值的表达式。这样的哲学鼓励你编写短小的方法，将大的方法拆成小的。另一方面，设计中的选择也是取决于上下文的，Scala 也允许你方便地编写有多个显示 return 的方法，如果那确实是你想要的。

   #+begin_src scala
     class ChecksumAccumulator {
       private var sum = 0
       def add(b: Byte) = sum += b
       def checksum() = ~(sum & 0xFF) + 1
     }

     /** 虽然 Scala 能够正确推到出 add 和 checksum 这两个方法的结果类型，
     但是代码的读者需要在脑海里推断（mentally infer）这些结果类型。
     所以，通常更好的做法是对类中声明为公有的方法显示地给出结果类型。
     ,**/

     class ChecksumAccumulator {
       private var sum = 0
       def add(b: Byte): Unit = {sum += b}
       def checksum(): Int = ~(sum & 0xFF) + 1
     }
   #+end_src

   #+RESULTS:
   : defined class ChecksumAccumulator
   : defined class ChecksumAccumulator
   
   结果类型为 Unit 的方法， 如 add 方法，执行的目的是为了它们的副作用。副作用通常来说指的是改变方法外部的某种状态或执行 I/O 的动作。就 add 而言，其副作用就是给 sum 重新赋值。

   那些仅仅因为其副作用而被执行的方法被称作过程（procedure）。

** 分号推断
   在 Scala 程序中，每条语句最后的分号通常是可选的。如果想要一条跨多行的语句，大多数情况下直接换行即可，比如：if-else。不过偶尔 Scala 也会背离你的意图，在不该断句的地方断句：
   #+begin_src scala
     x
     + y
   #+end_src
   
   这段代码会被解析成 x 和 +y。解决办法，当用中缀（infix）操作符比如 + 来串接表达式时，一个常见的 Scala 风格是将操作符放在行尾而不是行首：
   #+begin_src scala
     x +
     y +
     z
   #+end_src

   分号推理规则：

   概括的说，除非以下任何一条为 true，代码行的末尾就会被当作分号处理：

   1. 当前行以一个不能作为语句结尾的词结尾，比如英文句点或中缀操作符。

   2. 下一行以一个不能作为语句开头的词开头

   3. 当前行的行尾出现在圆括号（...）或方括号 [...] 内，因为再怎么说圆括号和方括号也不能（直接）包含多条语句。

** 单例对象
   Scala 比 Java 更面向对象一点，是 Scala 的类不允许有静态（static）成员。对此类使用场景，Scala 提供了单例对象（singleton object）。单例对象的定义看上去跟类定义很像，只不过 class 关键字被换成了 object 关键字。

   当单例对象跟某个类公用同一个名字是，它被称作这个类的伴生对象（companion object）。必须在同一个源文件中定义类和类的伴生对象。同时，类又叫作这个单例对象的伴生类（companion class）。类和它的伴生对象可以互相访问对方的私有成员。
   #+begin_src scala
     import scala.collection.mutable
     object ChecksumAccumulator {
       private val cache = mutable.Map.empty[String, Int]
       def calculate(s: String): Int =
         if (cache.contains(s))
           cache(s)
         else {
           val acc = new ChecksumAccumulator
           for(c <- s)
             acc.add(c.toByte)
           val cs = acc.checksum()
           cache += (s -> cs)
           cs
         }
     }

     class ChecksumAccumulator {
       private var sum = 0
       def add(b: Byte): Unit = {sum += b}
       def checksum(): Int = ~(sum & 0xFF) + 1
     }
   #+end_src

   单例对象并不仅仅是用来存放静态方法，它是一等的对象。意味着：可以被存入变数或其他结构；可以被作为参数传递给其他函数；可以被作为函数的返回值；可以在执行期创造，而无需完全在设计期全部写出；即使没有被系结至某以名称，也可以存在。

   定义单例对象并不会定义类型（在 Scala 的抽象层级上是这样）。

   类和单例对象的一个区别是单例对象不能接收参数，而类可以。每个单例对象都是通过一个静态变量引用合成类（synthetic class）的实例来实现的，因此单例对象从初始化的语义上跟 Java 的静态成员是一致的。尤其体现在，单例对象在有代码访问时才被初始化。

   没有同名的伴生类的单例对象称为孤立对象（standalone object）。
** Scala 应用程序
   要运行一个 Scala 程序，必须提供一个独立对象的名称。这个独立对象需要包含一个 main 方法，该方法接收一个 Array[String] 作为参数，结果类型为 Unit。任何带有满足正确签名的 main 方法的独立对象都能被用作应用程序的入口。
   
   Scala 在每一个 Scala 源码文件中都隐式地引入了 java.lang 和 scala 包的成员，以及名为 Predef 的单例对象的所有成员。
   
   Scala 和 Java 的区别之一，是 Java 要求你将公共的类放入跟类同名的文件中，而在 Scala 中可以任意命名 .scala 文件，不论你放什么类或代码到这个文件中。不过，通常对于那些非脚本的场景，把类放入以类名命名的文件是推荐的做法，就像 Java 那样。 

** App 特质

   Scala 提供了一个特质 scala.App，帮助你节省敲键盘的动作。
   
   #+begin_src scala
     object summer extends App {
       println("extend App")
     }

   #+end_src

   #+RESULTS:
   : defined object summer

   要使用这个特质，首先要在你的单例对象名后加上 "extends App"。然后，并不是直接编写 main 方法，而是将你打算放在 main 方法里的代码直接写在单例对象的花括号中。可以通过名为 args 的字符串数组来访问命令行参数。

* 第五章 基础类型和操作
** 一些基础类型
   Byte，Short，Int，Long 和 Char 类型统称为整数类型（integral type）。整数类型加上 Float 和 Double 称作数值类型（numeric types）。
   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/基础类型取值区间.png]]

   Scala 的基础类型跟 Java 中对应的类型取值区间完全相同，这使得 Scala 编译器可以在产出的字节码中将 Scala 的值类型（value types）转换成 Java 的基本类型（primitive type）。

** 字面量
   用于 Int，Long，Short 和 Byte 的整数字面量有两种形式：十进制的和十六进制的。如果是以 0x 或 0X 开头，意味着这是十六进制的数。如果字面量以非 0 的数字打头，且除此之外没有其他修饰，那么它就是十进制的。

   如果整数字面量以 L 或 l 结尾，那么它就是 Long 型的，否则就是 Int。

   如果一个 Int 型的字面量被赋值给一个类型为 Short 或 Byte 的变量，该字面量会被当作 Short 或 Byte 类型，只要这个字面量的值在对应类型的合法取值区间即可。

   #+begin_src scala
     val hex = 0x5
     val hex2 = 0x00FF
     val magic = 0xcafebabe

     val dec1 = 31
     val dec2 = 255
     val dec3 = 20

     val prog = 0XCAFEBABEL
     val tower = 35L
     val of = 311

     val little: Short = 367
     val littler: Byte = 38 
   #+end_src

   #+RESULTS:
   #+begin_example
   hex: Int = 5
   hex2: Int = 255
   magic: Int = -889275714
   dec1: Int = 31
   dec2: Int = 255
   dec3: Int = 20
   prog: Long = 3405691582
   tower: Long = 35
   of: Int = 311
   little: Short = 367
   littler: Byte = 38
   #+end_example

*** 浮点数字面量
   浮点数字面量由十进制的数字，可选的小数点（decimal point），以及后续一个可选的 E 或 e 打头的指数（exponent）组成。指数部分指的是对前一部分乘以 10 的多少次方。如果浮点数字面量以 F 或 f 结尾，那它就是 Float 型的；否则它就是 Double。Double 型的浮点数字面量也可以以 D 或 d 结尾，但这是可选的。
   
   #+begin_src scala
     val big = 1.2345
     val bigger = 1.2345e1
     val biggerStill = 123E45
   #+end_src

   #+RESULTS:
   : big: Double = 1.2345
   : bigger: Double = 12.345
   : biggerStill: Double = 1.23E47

  
*** 字符字面量
   字符字面量（character literal）由一对单引号和中间的任意 Unicode 字符组成。
   
   #+begin_src scala
   val a = 'A'
   #+end_src

   #+RESULTS:
   : a: Char = A

   除了显示地给出原字符，也可以用字符的 Unicode 码来表示。具体写法是 \u 加上 Unicode 码对应的四位的十六进制数字，如：

   #+begin_src scala
   val d = '\u0041'
   val f = '\u0044'
   #+end_src

   #+RESULTS:
   : d: Char = A
   : f: Char = D

   事实上，这样的 Unicode 字符可以出现在 Scala 程序的任何位置。比如说，可以像这样命名一个标示符（变量）：
   
   #+begin_src scala
   val B\u0041\u0044 = 1
   #+end_src

   #+RESULTS:
   : BAD: Int = 1

   通常来说，把标识符命名成这样并不好，因为不易读。这样的语法规则存在，本意上让包含非 ASCII 的 Unicode 字符的 Scala 源文件可以用 ASCII 表示。

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/特殊字符转义序列.png]]


*** 字符串字面量
   字符串字面量由双引号包起来的字符组成。
   
   #+begin_src scala
   val hello = "hello"
   val escapes = "\\\"\'"
   #+end_src

   #+RESULTS:
   : hello: String = hello
   : escapes: String = \"'

   由于这个语法对那些包含大量转义序列或者跨多行的字符串而言比较别扭，Scala 支持一种特殊的语法来表示原声字符串（raw string）。可以用三个双引号（"""）开始并以三个双引号结束来表示原声字符串。
   
   #+begin_src scala
   println("""Welcome to Ultamix 3000.
              Type "HELP" for help.""")
   #+end_src

   #+RESULTS:
   : Welcome to Ultamix 3000.
   :            Type "HELP" for help.

   这里的问题是字符串第二行前面的空格被包含在了字符串里！为了处理这个常见的情况，可以对字符串调用 stripMargin 方法。具体做法是在每一行开始加一个管道符号（|），然后对真个字符串调用 StripMargin：
   
   #+begin_src scala
   println("""Welcome to Ultamix 3000.
              |Type "HELP" for help.""")
   #+end_src

   #+RESULTS:
   : Welcome to Ultamix 3000.
   : Type "HELP" for help.

*** 符号字面量
   符号字面量（symbol literal）的写法是 'ident，其中 ident 可以是任何由字母和数字组成的标识符。这样的字面量会被映射成 scala.Symbol 这个预定义类的实例。确切地说，字面量 'cymbal 会被编译器展开成一个工厂方法的调用：Symbol("cymbal")。
   #+begin_src scala
     def updateRecordByName(r: Symbol, value: Any) = {
       // 具体代码
     }
   #+end_src

   #+RESULTS:
   : updateRecordByName: (r: Symbol, value: Any)Unit

   对于符号，你能做的不多，除了获取它的名称：
   
   #+begin_src scala
     val s = 'aSymbol
     val nm = s.name
   #+end_src

   #+RESULTS:
   : s: Symbol = 'aSymbol
   : nm: String = aSymbol

   另一个值得注意的点是符号会被内部化。如果同样的符号字面量出现两次，这两次引用都会指向同一个 Symbol 对象。

*** 布尔值字面量
   类型 Boolean 有两个字面量，true 和 false。

** 字符串插值
   Scala 包括了一个灵活的机制来支持字符串插值，允许你在字符串字面量中嵌入表达式。
   
   #+begin_src scala
   val name = "reader"
   println(s"Hello, $name!")
   #+end_src

   #+RESULTS:
   : name: String = reader
   : Hello, reader!

   表达式 s"Hello, $name!" 是一个被处理的（processed）字符串字面量。
   
   s插值器会对内嵌的每个表达式求值，对求值结果调用 toString，替换掉字面量中的那些表达式。

   可以随时使用美元符（$）开始一个表达式。如果表达式包含了非标识符字符，就必须将它放在花括号中，左花括号需要紧跟美元符。例如：

   #+begin_src scala
   s"The answer is ${6 * 7}."
   #+end_src

   #+RESULTS:
   : res73: String = The answer is 42.
   
   Scala 默认还提供了另外两种字符串插值器：raw 和 f。raw 字符串插值器的行为跟 s 类似，不过它并不识别字符转义序列。

   #+begin_src scala
   raw"No\\\\escape!"
   #+end_src

   #+RESULTS:
   : res75: String = No\\\\escape!

   f 字符串插值器允许你给内嵌的表达式加上 printf 风格的指令。需要将指令放在表达式后，以百分号（%）开始，使用 java.util.Formatter 中给出的语法。

   #+begin_src scala
   f"${math.Pi}%.5f"
   #+end_src

   #+RESULTS:
   : res77: String = 3.14159
   
   如果不对内嵌表达式给出任何格式化指令，f 字符串插值器将默认使用 %s，其含义是用 toString 的值来替换，就像 s 字符串插值器那样。

** 操作符即方法
   Int 包含了多个重载（overloaded）的 + 方法，分别接收不同的参数类型。
    
   在 Scala 中，操作符并不是特殊的语法，任何方法都可以是操作符。

   中缀操作符表示法意味着被调用的方法名位于对象和你想传入的参数中间。Scala 还提供了另外两种操作符表示法：前缀和后缀。跟中缀操作符表示法（操作符接收两个操作元，一个在左一个在右）不同。前缀和后缀操作符是一元的（unary）：它们只接收一个操作元。跟中缀操作符类似，这些前缀操作符也是调用方法的一种简写。不同的是，方法名称是“unary_”加上操作符。唯一能被用作前缀操作符的是 +，-，！和 ～。后缀操作符是哪些不接收参数并且调用时没有英文句点圆括号的方法。在 Scala 中，可以在方法调用时省去空的圆括号。从约定俗成的角度讲，如果方法有副作用的时候保留空的圆括号，比如 println()；而在方法没有副作用时则可以省掉这组圆括号。

   #+begin_src scala
     val sum = 1 + 2
     val sum = 1.+(2)
     val sum = 1 + 2L

     val s = "Hello, world!"
     s indexOf 'o'
     s indexOf ('o', 5)

     -2.0
       (2.0).unary_-

   #+end_src

   #+RESULTS:
   : sum: Int = 3
   : sum: Int = 3
   : sum: Long = 3
   : s: String = Hello, world!
   : res79: Int = 4
   : res80: Int = 8
   : res81: Double = -2.0
   : res82: Double = -2.0

** 算数操作
   当左右两个操作元都是整数类型（Int，Long，Byte，Short 或 Char）时，/ 操作符只会计算出商的整数部分。

** 关系和逻辑操作
   && 和 || 跟 Java 一样是短路的（short-circuit）
   
   既然操作符只是方法，短路是如何做到的。通常，所有入参都会在进入方法之前被求值，但是所有 Scala 方法都有一个机制来延迟对入参的求值，或者干脆不对他们求值。这个机制叫做传名参数（by-name parameter）。

** 位运算符
   位运算方法有：按位与（&），按位或（|）和按位异或（^）。一元的位补码操作（~，unary_~方法)对操作元的每一位取反。

   Scala 整数类型还提供了三个位移（shift）方法，左移（<< ）,右移（>>）和无符号右移（>>>）

** 对象相等性
   ==，！=
   
   这些操作际上可以被应用于所有的对象，并不仅仅是基础类型。
   
   #+begin_src scala
   List(1,2,3) == List(1,2,3)
   List(1,2,3) == List(4,5,6)
   #+end_src

   #+RESULTS:
   : res84: Boolean = true
   : res85: Boolean = false

   还可以比较不同类型的两个对象：
   
   #+begin_src scala
   1 == 1.0
   List(1, 2, 3) == "hello"
   #+end_src

   #+RESULTS:
   : res87: Boolean = true
   : res88: Boolean = false

   甚至可以拿对象跟 null 做比较，或者跟可能为 null 的对象做比较。不会抛出异常：
   
   #+begin_src scala
   List(1, 2, 3) == null
   null == List(1, 2, 3)
   #+end_src

   这背后的规则很简单：首先检查左侧是否为 null，如果不为 null，调用 equals 方法。

   这种比较逻辑对于不同的对象，只要它们的内容一致，且 equals 方法的实现也是完全基于内容的情况下，都会交出 true 答案。

   在 Java 中，可以用 == 来比较基本类型和引用类型。
   
   对于基本类型而言 Java 的 == 比较的是值的相等性，就跟 Scala 一样。

   但是对于引用类型，Java 的 == 比较的是引用相等性（reference equality），意思是两个变量指向 JVM 的堆上的同一个对象。Scala 也提供了用于比较引用相等性的机制，即名为 eq 的方法。

** 操作符优先级和结合性
   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/操作符优先级.png]]

** 富包装类
   每一个基础类型都有一个对应的富包装类，提供了额外的方法。
   
   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/富包装类.png]]


* 第六章 函数式对象
   本章的重点是那些定义函数式对象的类，或者那些没有任何可变状态的对象。

   通过实现一个有理数类来进行说明。

** 构建 Rational
   
   #+begin_src scala
   class Rational(n: Int, d: Int)
   #+end_src

   #+RESULTS:
   : defined class Rational

   如果一个类没有定义体，并不需要给出空的花括号（只要你想，当然也可以）。类名 Rational 后的圆括号中的标识 n 和 d 称作类参数（class parameter）。Scala 编译器将会采集到这两个类参数，并且创建一个主构造方法（primary constructor），接收同样的这两个参数。

   Scala 编译器会将你在类定义体中给出的非字段或方法定义的代码编译进类的主构造方法中。
   
   #+begin_src scala
   class Rational(n:Int, d: Int) {
     println("Created " + n + "/" + d)
   }
   new Rational(1, 2)
   #+end_src

   #+RESULTS:
   : defined class Rational
   : Created 1/2
   : res92: Rational = Rational@6519cd8a

   跟可变对象相比，不可变对象具有若干优势和一个潜在的劣势。首先，不可变对象通常比可变对象更容易推理。其次，可以相当自由地传递不可变对象，而对于可变对象，在传递给其他代码之前，你可能需要对它们做保护式的拷贝。再次，假如有两个并发的线程同时访问某个不可变对象，它们没有机会在对象正确构造以后破坏其状态，因为没有线程可以改变某个不可变对象的状态。最后，不可变对象可以安全地用作哈希表里的键。

   不可变对象的主要劣势是它们有时候会需要拷贝一个大的对象图，而实际上也许一个局部的更新也能满足要求。在某些场景下，不可变对象可能用起来比较别扭，同时还带来性能瓶颈。因此，类库对于不可变的类也提供可变的版本这样的做法并不罕见。例如： StringBuilder 类就是对不可变的 String 类的一个可变的替代。

** 重新实现 toString 方法
   解释器是通过对 Rational 对象调用 toString 来获取到这个看上去有点奇怪的字符串的。Rational 类默认继承了 java.lang.Object 类的 toString 实现。可以通过给 Rational 类添加 toString 方法来重写（override）默认的实现。
   
   #+begin_src scala
   class Rational(n: Int, d: Int) {
     override def toString = n + "/" + d
   }
   new Rational(1, 2)
   #+end_src

   #+RESULTS:
   : defined class Rational
   : a: Rational = 1/2
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evaluWzmTQ:17: error: value n is not a member of Rational
   :        a.n
   :          ^

** 检查前置条件
   面向对象编程的一个好处是可以将数据封装在对象里，以确保整个生命周期中数据都是合法的。对于 Rational 这样的不可变对象而言，这意味着需要确保对象在构造时数据合法。由于对 Rational 数来说分母为 0 是非法的状态，当 0 作为参数 d 传入的时候，不应该允许这样的 Rational 被创建出来。

   解决这个问题的最佳方式是对主构造方法定义一个前置条件（precondition），d 必须为非 0 值。前置条件是对传入方法或构造方法的值的约束，这是方法调用者必须满足的。实现这个的一种方式是用 require。

   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       override def toString = n + "/" + d
     }
     new Rational(1,2)
     new Rational(5,0)
   #+end_src

   #+RESULTS:
   : defined class Rational
   : res96: Rational = 1/2
   : java.lang.IllegalArgumentException: requirement failed
   :   at scala.Predef$.require(Predef.scala:212)
   :   ... 60 elided

** 添加字段
   #+begin_src scala
     class Rational(n: Int, b: Int) {
       require(d != 0)
       override def toString = n + "/" + d
       def add(r: Rational): Rational =
         new Rational(n * r.d + r.n * d, d * r.d)
     }
   #+end_src

   #+RESULTS:
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalGh7WdJ:21: error: value d is not a member of Rational
   :            new Rational(n * that.d + that.n * d, d * that.d)
   :                                  ^
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalGh7WdJ:21: error: value n is not a member of Rational
   :            new Rational(n * that.d + that.n * d, d * that.d)
   :                                           ^
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalGh7WdJ:21: error: value d is not a member of Rational
   :            new Rational(n * that.d + that.n * d, d * that.d)
   :                                                           ^
   
   这段代码编译器回报错：

   虽然类参数 n 和 d 在你的 add 方法的作用域内，只能访问执行 add 调用的那个对象上的 n 和 d 的值。 因此，当你在 add 实现中用到 n 和 d 时，编译器会提供这些类参数对应的值，但它并不允许使用 that.n 或 that.d，因为 that 并非指向你执行 add 调用的那个对象。要访问 that 的分子和分母，需要将他们做成字符。

   #+begin_src scala
     class Rational(n: Int, d: Int) {
       override def toString = n + "/" + d
     }
     val r = new Rational(1, 2)
     r.n
   #+end_src

   #+RESULTS:
   : defined class Rational
   : r: Rational = 1/2
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evaltF9HIU:17: error: value n is not a member of Rational
   :        r.n
   :          ^

   可以看出 n 和 d 并不是字段，只是类参数，所以不能使用 that.n 或 that.d 来访问。
   
   下面这个版本能够编译通过。
   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       val numer: Int = n
       val denom: Int = d
       override def toString = numer + "/" + denom
       def add(that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
     }
   #+end_src

   #+RESULTS:
   : defined class Rational

** 自引用
   关键字 this 指向当前执行方法的调用对象，当用在构造方法里的时候，指向被构造的对象实例。
   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       val numer: Int = n
       val denom: Int = d
       override def toString = numer + "/" + denom
       def add(that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
       def lessThan(that: Rational) = this.numer * that.denom < that.numer * this.numer
       def max(that: Rational) = if(this.lessThan(that)) that else this
     }
   #+end_src

   #+RESULTS:
   : defined class Rational
   
   lessThan 里的的 this 可以省略只写 numer。这两种表示法是等效的。

   max 里第一个 this 是冗余的。但是第二个 this 是必须的。

** 辅助构造方法
   在 Scala 中， 主构造方法之外的构造方法称为辅助构造方法（auxiliary constructor）。

   在 Scala 中，每个辅助构造方法都必须首先调用同一个类的另一个构造方法。换句话说，Scala 每个辅助就构造方法的第一条语句都必须是这样的形式：this(...)。被调用的构造方法要么是主构造方法，要么是另一个出现在发起调用的构造方法之前的另一个辅助构造方法。这个规则的净效应是 Scala 的每个构造方法最终都会调用到该类的主构造方法。这样一来，主构造方法就是类的单一入口。
   #+begin_src scala
   class Rational(n: Int, d: Int) {
       require(d != 0)
       val numer: Int = n
       val denom: Int = d
       def this(n: Int) = this(n, 1)  // auxiliary constructor
       override def toString = numer + "/" + denom
       def add(that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
       def lessThan(that: Rational) = this.numer * that.denom < that.numer * this.numer
       def max(that: Rational) = if(this.lessThan(that)) that else this
     }
   #+end_src

   #+RESULTS:
   : defined class Rational

   为什么 Scala 的构造方法规则比 Java 更严格。在 Java 中，构造方法要么调用同一个类的另一个构造方法，要么直接调用超类的构造方法。而在 Scala 类中，只用主构造方法可以调用超类的构造方法。Scala 这个增强的限制实际上是一个设计的取舍，用来换取更精简的代码和跟 Java 相比更为简单的构造方法。

** 私有字段和方法
   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       private val g = gcd(n.abs, d.abs)
       val numer: Int = n / g
       val denom: Int = d / g
       def this(n: Int) = this(n, 1)  // auxiliary constructor
       override def toString = numer + "/" + denom
       def add(that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
       def lessThan(that: Rational) = this.numer * that.denom < that.numer * this.numer
       def max(that: Rational) = if(this.lessThan(that)) that else this
       private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b )
       }

   #+end_src

   #+RESULTS:
   : defined class Rational

** 定义操作符   
   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       private val g = gcd(n.abs, d.abs)
       val numer: Int = n / g
       val denom: Int = d / g
       def this(n: Int) = this(n, 1)  // auxiliary constructor
       override def toString = numer + "/" + denom
       def + (that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
       def * (that: Rational): Rational = new Rational(numer * that.numer, denom * that.numer)
       def lessThan(that: Rational) = this.numer * that.denom < that.numer * this.numer
       def max(that: Rational) = if(this.lessThan(that)) that else this
       private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b )
     }
   #+end_src

   #+RESULTS:
   : defined class Rational

   
** Scala 中的标识符
   Scala 遵循了 Java 的驼峰命名法（camel-case）命名标识符的传统。一个原因是跟 Java 保持一致，另一个原因是下划线在 Scala 代码中还有许多其他非标识符的用法。字段，方法参数，局部变量和函数的驼峰命名应该以小写字母打头，类和特质的驼峰命名应该以大写字母打头。

   在常量命名上， Scala 的习惯与 Java 不同。在 Scala 中，常量（constant）这个词并不意味着 val。虽然 val 在初始化之后确实不会变，但它仍然是个变量。举个例子来说，方法参数是 val，但方法每次别调用是，这些 val 都可以拿到不一样的值。而一个常量更永固。Java 对常量的命名习惯是全大写，并用下划线分隔开不同的单词，比如 MAX_VALUE 或 PI。而 Scala 的命名习惯只要求首字母大写。

   操作表示符（operator identifier）：略

   混合标识符（mixed identifier）由一个字母数字组合操作符，一个下划线和一个符号操作符组成。例如：unary_+

   字面标识符（literal identifier）是用反引号括起来的任意字符串。略


** 方法重载
   Scala 解析重载方法的过程跟 Java 很像。在每个具体的案例中，被选中的是那个最匹配入参静态类型的重载版本。

** 隐式转换
   如何写成 2 * r。解决办法：可以创建一个隐式转换（implicit conversion）。在需要时自动将整数转换成有理数。为了让隐式转换能工作，它需要在作用域内。如果你将隐士方法的定义放在 Rational 类内部，对解释器而言它是没有在作用域的。

* 第七章 内建的控制结构
  你会注意到一点，那就是 Scala 所有的控制结构都返回某种值作为结果。缺少了这个机制，程序员必须创建临时的变量，这些变量仅仅是用来保持那些在控制结构内部计算出来的结果。去掉这些临时变量不仅让代码变得更简单，同时还避免了很多由于在某个分支设置了变量而在另一个分支中忘记设置带来的bug。
  
** if 表达式
  #+begin_src scala
    var filename = if (!args.isEmpty) args(0) else "default.txt"
  #+end_src
  
  使用 val 而不是 var 的另一个好处是对等式推理（equational reasoning）的支持。引入的变量等于计算出它的值的表达式（假定这个表达式没有副作用）。因此，在任何你打算写变量名的地方，都可以直接用表达式来替换。
  
  只要有机会，尽可能使用 val，它们会让你的代码更易读也更易于重构。

** while 循环
   while 和 do-while 这样的语法结构，我们称之为“循环”而不是表达式，因为它们并不会返回一个有意义的值。返回值的类型是 Unit。实际上存在这样一个（也是唯一的一个）类型为 Unit 的值。这个值叫作单元值（unit value），写作()。存在这样一个()值，是 Scala 的 Unit 跟 Java 的 void 的不同。
   #+begin_src scala
     def greet() = {println("hi")}
     () == greet()
   #+end_src

   #+RESULTS:
   : greet: ()Unit
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalD5wf6X:17: warning: comparing values of types Unit and Unit using `==' will always yield true
   :        () == greet()
   :           ^
   : hi
   : res121: Boolean = true

** for 表达式
*** 遍历集合
   #+begin_src scala
     val filesHere = (new java.io.File(".")).listFiles
     for (file <- filesHere)
       println(file)
   #+end_src

   #+RESULTS:
   #+begin_example
   filesHere: Array[java.io.File] = Array(./build.sbt~, ./.DS_Store, ./ensime.sbt, ./derby.log, ./Makefile, ./target, ./.ensime, ./.ensime_cache, ./project, ./.gitignore, ./spark-warehouse, ./.projectile, ./README.org, ./tmp.scala~, ./.git, ./.scalafmt.conf~, ./metastore_db, ./.gitignore~, ./Makefile~, ./build.sbt, ./ensime.sbt~, ./src)
   ./build.sbt~
   ./.DS_Store
   ./ensime.sbt
   ./derby.log
   ./Makefile
   ./target
   ./.ensime
   ./.ensime_cache
   ./project
   ./.gitignore
   ./spark-warehouse
   ./.projectile
   ./README.org
   ./tmp.scala~
   ./.git
   ./.scalafmt.conf~
   ./metastore_db
   ./.gitignore~
   ./Makefile~
   ./build.sbt
   ./ensime.sbt~
   ./src
   #+end_example

   通过“file <- filesHere” 这样的生成器（generator）语法进行遍历。
   
   for 表达式的语法可以用于任何种类的集合，而不仅仅是数组。Range（区间）是一类特殊的用例。
   
   #+begin_src scala
     for (i <- 1 to 4)
       println("Iteration " + i)
   #+end_src

   #+RESULTS:
   : Iteration 1
   : Iteration 2
   : Iteration 3
   : Iteration 4

   如果你不想在遍历的值中包含区间的上界，可以用 util 而不是  to。

*** 过滤
   有时你并不想完整地遍历集合，你想把它过滤成一个子集。这时可以给 for 表达式添加过滤器（filer），过滤器是 for 表达式的圆括号中的一个 if 子句。可以随意包含更多的过滤器，直接添加 if 子句即可。
   #+begin_src scala
     val filesHere = (new java.io.File(".")).listFiles
     for (
       file <- filesHere
       if file.isFile
       if file.getName.endsWith(".scala")
     )
   #+end_src

*** 嵌套迭代
   如果你添加多个 <- 子句，你讲得到嵌套的循环。

   如果你愿意，也可以使用花括号而不是圆括号来包括生成器和过滤器。这样做的一个好处是可以在需要时省去某些分号，因为 Scala 编译器在圆括号中并不会自动推断分号。
   #+begin_src scala
     def fileLines(file: java.io.File) =
       scala.io.Source.fromFile(file).getLines().toList

     def grep(pattern: String) =
       for (
         file <- filesHere
         if file.getName.endsWith(".scala");
         line <- fileLines(file)
         if line.trim.matches(pattern)
       ) println(file + ": " + line.trim)

     grep(".*gcd.*")
   #+end_src

   #+RESULTS:
   : fileLines: (file: java.io.File)List[String]
   : grep: (pattern: String)Unit

*** 中途（mid-stream）变量绑定
   可以用 = 来将表达式的结果绑定到新的变量上。被绑定的这个变量引入和使用起来都跟 val 一样。

   #+begin_src scala
     val filesHere = (new java.io.File(".")).listFiles

     def fileLines(file: java.io.File) =
       scala.io.Source.fromFile(file).getLines().toList
     def grep(pattern: String) =
       for {
         file <- filesHere
         if file.getName.endsWith(".scala");
         line <- fileLines(file)
         trimmed = line.trim
         if trimmed.matches(pattern)
       } println(file + ": " + trimmed)
     grep(".*gcd.*")
   #+end_src

   #+RESULTS:
   : filesHere: Array[java.io.File] = Array(./build.sbt~, ./.DS_Store, ./ensime.sbt, ./derby.log, ./Makefile, ./target, ./.ensime, ./.ensime_cache, ./project, ./.gitignore, ./spark-warehouse, ./.projectile, ./README.org, ./tmp.scala~, ./.git, ./.scalafmt.conf~, ./metastore_db, ./.gitignore~, ./Makefile~, ./build.sbt, ./ensime.sbt~, ./src)
   : fileLines: (file: java.io.File)List[String]
   : grep: (pattern: String)Unit

*** 产出一个新的集合
    虽然目前为止所有示例都是对遍历到的值进行操作然后忘掉它们，也完全可以在买次迭代中生成一个被记住的值。具体做法是在 for 表达式的代码体之前加上关键字yield。
    
    要小心 yield 关键字的位置。for-yield 表达式的语法如下：
    
    for 子句 yield 代码体

    yield 关键字必须出现在真个代码体之前。哪怕代码体是由花括号包卡来的，也要将 yield 放在花括号之前，而不是代码块的最后一个表达式前面。

    #+begin_src scala
     val filesHere = (new java.io.File(".")).listFiles

      val forLineLengths =
        for {
          file <- filesHere
          if file.getName.endsWith(".scala")
          line <- fileLines(file)
          trimmed = line.trim
          if trimmed.matches(".*for.*")
        } yield trimmed.length
    #+end_src

    #+RESULTS:
    : filesHere: Array[java.io.File] = Array(./build.sbt~, ./.DS_Store, ./ensime.sbt, ./derby.log, ./Makefile, ./target, ./.ensime, ./.ensime_cache, ./project, ./.gitignore, ./spark-warehouse, ./.projectile, ./README.org, ./tmp.scala~, ./.git, ./.scalafmt.conf~, ./metastore_db, ./.gitignore~, ./Makefile~, ./build.sbt, ./ensime.sbt~, ./src)
    : forLineLengths: Array[Int] = Array()

** 用 try 表达式实现异常处理
*** 排除异常
    在 Scala 中抛出异常跟 Java 看上去一样。你需要创建一个异常对象然后用 throw 关键字将它抛出。
    #+begin_src scala
      val half =
        if (n % 2 ==0)
          n / 2
        else
          throw new RuntimeException("n must be even")
    #+end_src
    
    在 Scala 中 throw 是一个有结果类型的表达式。抛出异常这个表达式的类型是 Nothing。哪怕表达式从不实际被求值，也可以用 throw。这个技术细节听上去有点奇怪，不过在前一例这样的场景次下，还是很常见也很有用的。if 的一个分支计算出某个值，而另一个分支抛出异常并计算出 Nothing。整个 if 表达式的类型就是那个计算出的某个值的分支类型。
    
*** 捕获异常
    catch 子句的语法之所以是这样，为的是与 Scala 的一个重要组成部分，模式匹配（pattern matching），保持一致。

    #+begin_src scala
      import java.io.FileReader
      import java.io.FileNotFoundException
      import java.io.IOException

      try {
        val f = new FileReader("input.txt")
      } catch {
        case ex: FileNotFoundException => println("找不到文件")
        case ex: IOException => println("I/O 错误")
      }
    #+end_src

    #+RESULTS:
    : import java.io.FileReader
    : import java.io.FileNotFoundException
    : import java.io.IOException
    : 找不到文件
    
    一个 Scala 和 Java 的区别，Scala 并不要求你捕获受检异常（checked exception）或在 throws 子句里声明。可以选择用 @throws 注解来声明一个 throws 子句，但这并不是必须的。

*** finally 子句
    

*** 交出值
    如果没有异常抛出，真个表达式的结果就是 try 子句的结果；如果有异常抛出并且被捕获时，整个表达式的结果就是对应的 catch 子句的结果；而如果有异常抛出但没有被捕获，整个表达式就没有结果。如果有 finally 子句，该子句计算出来的值会被丢弃。finally 子句一般都是执行清理工作。

    需要注意的是 Scala 的行为跟 Java 不同，仅仅是因为 Java 的 try-finally 并不返回某个值。跟 Java 一样， 当 finally 子句包含一个显示的返回语句，或者抛出某个异常，那么这个返回值或异常将会“改写”（overrule）任何在之前的 try 代码块或者某个 catch 子句中产生的值。
    
    #+begin_src scala
    def f(): Int = try return 1 finally return 2
    #+end_src

    调用 f() 将得到 2。

    #+begin_src scala
    def g(): Int = try 1 finally 2
    #+end_src
    
    调用 g() 将得到 1。

** match 表达式
   Scala 的 match 表达式让你从若干可选项（alternative）中选择，就像其他语言中的 switch 语句那样。缺省的样例以下划线（_）表示，这个通配符在 Scala 中经常用来表示某个完全不知道的值。

   #+begin_src scala
     val firstArg = if (args.length > 0) args(0) else ""
     firstArg match {
       case "salt" => println("pepper")
       case "chips" => println("salsa")
       case "eggs" => println("bacon")
       case _ => println("huh?")
     }
   #+end_src

   #+RESULTS:
   : args: Array[String] = Array(salt)
   : firstArg: String = salt
   : pepper

   Scala 的 match 表达式跟 Java 的 switch 相比，有一些重要的区别。其中一个区别是任何常量，字符串等都可以用作样例，而不仅限于 Java 的 case 语句支持的整型，枚举和字符串常量。另一个区别是每个可选项的最后并没有 break。在 Scala 中 break 是隐含的，并不会出现某个可选项执行完继续执行下一个可选项的情况。

   不过 Scala 的 match 表达式跟 Java 的 switch 相比最显著的不同，在于 match 表达式会返回值。这样的代码不仅更短，它还将两件不同的事情解藕了：首先选择食物，然后将时候打印出来。
   
   #+begin_src scala
     val firstArg = if (args.length > 0) args(0) else ""
     val friend = firstArg match {
       case "salt" => "pepper"
       case "chips" => "salsa"
       case "eggs" => "bacon"
       case _ => "huh?"
     }

     println(friend)
   #+end_src

** 没有 break 和 continue 的日子
   DEADLINE: <2018-05-14 Mon>
   Scala 去掉了 break 和 continue 这两个命令。

   最简单的方式是用 if 替换掉每个 continue。用布尔值换掉每个 break。 如果想去掉 var 可以将循环写成递归。

   #+begin_src scala
     def searchFrom(i: Int): Int =
       if (i >= args.length) -1
       else if (args(i).startsWith("-")) searchFrom(i + 1)
       else if (args(i).endsWith(".scala")) i
       else searchFrom(i + 1)
     val i = searchFrom(0)
   #+end_src

   由于所有的递归调用都发生在函数尾部（tail-call position），编译器会生成与 while 循环类似的代码。每一次递归都会被实现成跳回函数开始的位置。
   
   如果经过这些讨论你扔觉得需要使用 break，Scala 标准库也提供了帮助。Scala.util.control 包的 Break 类给出了一个 break 方法，可以被用来退出包含它的 breakable 标记的代码块。
   
** 变量作用域

   Java 和 Scala 的一个区别是 Scala 允许你在嵌套的作用域内定义同名的变量。
   
   关于作用域最长见的例子是花括号一般都会引入一个新的作用域，因此任何在花括号中定义的元素都会在花括号之后离开作用域。

   可以在一个内嵌的作用域内定义一个跟外部作用域中相同名称的变量。

   #+begin_src scala
   val a = 1;
   {
     val a = 2
     println(a)
   }
   println(a)
   #+end_src

   #+RESULTS:
   : a: Int = 1
   : 2
   : 1

   在 Scala 程序中，内嵌作用域中的变量会遮挡（shadow）外部作用域中相同名称的变量，因为外部作用域的同名变量在内嵌作用域内将不可见。

** 对指令式代码进行重构
   #+begin_src scala
     def makeRowSeq(row: Int) = 
       for(col <- 1 to 10) yield {
         val prod = (row * col).toString
         val padding = " " * (4 - prod.length)
         padding + prod
       }

     def makeRow(row: Int) = makeRowSeq(row).mkString

     def multiTable() = {
       val tableSeq = ""
       for(row <- 1 to 10 )
       yield makeRow(row)
       tableSeq.mkString
     }
   #+end_src

   #+RESULTS:
   : makeRowSeq: (row: Int)scala.collection.immutable.IndexedSeq[String]
   : makeRow: (row: Int)String
   : multiTable: ()String

* 第八章 函数和闭包
   事实上，Scala 提供了好几种 Java 中没有的方式来定义函数。除了方法（即那些以某个对象的成员形式存在的函数）之外，还有嵌套函数，函数字面量和函数值等。
   
** 方法
   定义函数最常用的方式是作为某个对象的成员，这样的函数被称为方法（method）。

   #+begin_src scala
     import scala.io.Source

     object LongLines {
       def processFile(filename: String, width: Int) = {
         val source = Source.fromFile(filename)
         for (line <- source.getLines())
           processLine(filename, width, line)
       }

       private def processLine(filename: String, width: Int, line: String) = {
         if (line.length > width)
           println(filename + ":" + line.trim)
       }
     }
   #+end_src

   #+RESULTS:
   : import scala.io.Source
   : defined object LongLines

** 局部函数
   前一节的 processFile 方法的构建展示了函数式编程风格的一个重要设计原则：程序应该被分解成许多小函数，每个函数都只做明确定义的任务。单个函数通常都很小。这种风格的好处是可以让程序员灵活地将许多构建单元组装起来，完成更复杂的任务。每个构建单元都应该足够简单，简单到能够单独理解的程度。

   这种方式的一个问题是助手函数的名称会污染整个程序的命名空间。在解释器中，这并不是太大的问题，不过一旦函数被打包进可复用的类和对象当中，我们通常都希望类的使用者不要直接看到这些函数。它们离开类和对象单独存在时通常都没有什么意义，而且通常你都希望在后续采用其他方式重写该类时，保留删除助手函数的灵活性。

   在 Java 中，帮助你达到此目的的主要工具是私有方法。这种私有方法的方式在 Scala 中同样有效。不过 Scala 还提供了另一种思路：可以在某个函数内部定义函数。就像局部变量一样，这样的局部函数只在包含它的代码块中可见。

   #+begin_src scala
     import scala.io.Source

     object LongLines {
       def processFile(filename: String, width: Int) = {
         def processLine(line: String) = {
           if (line.length > width)
             println(filename + ":" + line.trim)
         }
         val source = Source.fromFile(filename)
         for (line <- source.getLines())
           processLine(line)
       }
     }

   #+end_src

   #+RESULTS:
   : import scala.io.Source
   : defined object LongLines

** 一等函数
   Scala 支持一等函数。不仅可以定义函数并调用它们，还可以用匿名的字面量来编写函数并将它们作为值（value）进行传递。

   函数字面量被编译成类，并在运行时实例化成函数值（function value）。因此，函数字面量和函数值的区别在于，函数字面量存在于源码，而函数值以对象形式存在域运行时。这跟类（源码）与对象（运行时）的区别很相似。

   函数值是对象，所以可以将它们存放在变量中。它们同时也是函数，所以也可以用常规的圆括号来调用它们。

** 函数字面量的简写形式
   Scala 提供了多个省去冗余信息，更简要地编写函数的方式。你需要留意这些机会，因为它们能帮助你去掉多余的代码。

   一种让代码变得更简要的方式是略去参数类型声明。

   #+begin_src scala
     val someNumbers = List(-11, -10, -5, 0, 5, 10)
     someNumbers.filter((x: Int) => x > 0)

     someNumbers.filter((x) => x > 0)
   #+end_src

   #+RESULTS:
   : someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
   : res10: List[Int] = List(5, 10)
   : res11: List[Int] = List(5, 10)

   Scala 编译器知道 x 必定是整数，因为它看到你立即用这个函数来过滤一个由整数组成的列表。这被称作目标类型（target typing），因为一个表达式的目标使用场景可以影响该表达式的类型。

   另一个去除源码中无用字符的方式是省去某个靠类型推断的参数两侧的括号。 

   #+begin_src scala
     val someNumbers = List(-11, -10, -5, 0, 5, 10)
     someNumbers.filter(x => x > 0)
   #+end_src

   #+RESULTS:
   : someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
   : res13: List[Int] = List(5, 10)

** 占位符语法
   为了让函数字面量更加精简，还可以使用下划线作为占位符，用来表示一个或多个参数，只要满足每个参数只在函数字面量中出现一次即可。

   #+begin_src scala
     val someNumbers = List(-11, -10, -5, 0, 5, 10)
     someNumbers.filter(_ > 0)
   #+end_src

   #+RESULTS:
   : someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
   : res15: List[Int] = List(5, 10)

   有时候当你用下划线为参数占位符时，编译器可能并没有足够多的信息来推断缺失的参数类型。这类情况下，可以用冒号来给出类型。
   
   #+begin_src scala
     val f = _ + _

     val f = (_: Int) + (_: Int)
   #+end_src

   #+RESULTS:
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalCnO4zp:14: error: missing parameter type for expanded function ((x$1, x$2) => x$1.$plus(x$2))
   :        val f = _ + _
   :                ^
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalCnO4zp:14: error: missing parameter type for expanded function ((x$1: <error>, x$2) => x$1.$plus(x$2))
   :        val f = _ + _
   :                    ^
   : f: (Int, Int) => Int = <function2>

   注意， _ + _ 将会展开成一个接收两个参数的函数字面量。这就是为什么只有当每个参数在函数字面量中出现不多不少正好一次的时候才能使用这样的精简写法。多个下划线意味着多个参数，而不是对单个参数的重复使用。

** 部分应用的函数
   虽然前面的例子用下划线替换掉单独的参数，也可以用下划线替换整个参数列表。
   
   #+begin_src scala
     val someNumbers = List(-11, -10, -5, 0, 5, 10)   
     someNumbers.foreach(println _)
     someNumbers.foreach(println)
   #+end_src

   #+RESULTS:
   #+begin_example
   someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
   -11
   -10
   -5
   0
   5
   10
   -11
   -10
   -5
   0
   5
   10
   #+end_example
   
   当你这样使用下划线时，实际上时在编写一个部分应用的函数（partially applied function）。在 Scala 中，当你调用某个函数，传入任何需要的参数时，你实际上是应用那个函数到这些参数上。
   
   部分应用的函数是一个表达式，在这个表达式中，并不给出函数需要的所有参数，而是给出部分，或者完全不给。
   
   #+begin_src scala
     def sum(a: Int, b: Int, c:Int) = a + b + c

     sum(1,2,3)

     val a = sum _

     a(1,2,3)
     
     a.apply(1,2,3)
   #+end_src

   #+RESULTS:
   : sum: (a: Int, b: Int, c: Int)Int
   : res0: Int = 6
   : a: (Int, Int, Int) => Int = <function3>
   : res1: Int = 6
   : res2: Int = 6

   例子背后发生的事情：名为 a 的变量指向一个函数值对象。这个函数值是一个从 Scala 编译器自动从 sum _ 这个部分应用函数表达式生成的类的实例。有编译器生成的这个类有一个接收三个参数的 apply 方法。生成的类的 apply 方法之所以接收三个参数，是因为表达式 sum _ 缺失的参数转发给 sum，然后返回结果。

   这是一种将 def 变成函数值的方式。

   #+begin_src scala
     def sum(a: Int, b: Int, c: Int) = a + b + c
     val b = sum(1, _: Int, 3)

     b(2)
   #+end_src

   #+RESULTS:
   : sum: (a: Int, b: Int, c: Int)Int
   : b: Int => Int = <function1>
   : res5: Int = 6

   如果你要的部分应用函数表达式并不给出任何参数，比如 println _ 或 sum _，可以在需要这样一个函数的地方更加精简的表示，连下划线也不用写。这种形式只在明确需要函数的地方被允许。在那些并不需要函数的场合，尝试使用这样的形式会引发编译错误。
   
   #+begin_src scala
     def sum(a: Int, b: Int, c: Int) = a + b + c
     val c = sum
     val d = sum _
   #+end_src

   #+RESULTS:
   : sum: (a: Int, b: Int, c: Int)Int
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalGbBq7f:12: error: missing argument list for method sum
   : Unapplied methods are only converted to functions when a function type is expected.
   : You can make this conversion explicit by writing `sum _` or `sum(_,_,_)` instead of `sum`.
   :        val c = sum
   :                ^
   : d: (Int, Int, Int) => Int = <function3>

   Scala 同行要求你明确指出那些你特意省去的参数，哪怕只是简单地加上 _ 就好。Scala 仅仅在明确预期函数类型的地方允许你省掉 _。

** 闭包
   
   #+begin_src scala
     (x: Int) => x + more

   #+end_src
   
   more 是一个自由变量（free variable）,因为函数字面量本身并没有给 more 赋予任何含义。相反，x 是一个绑定变量（bound variable），因为它在该函数的上下文里有明确的含义：它被定义为该函数的唯一参数。

   #+begin_src scala
     var more = 1

     val addMore = (x: Int) => x + more

     addMore(10)
   #+end_src

   #+RESULTS:
   : more: Int = 1
   : addMore: Int => Int = <function1>
   : res8: Int = 11

   运行时，从这个函数字面量创建出来的函数值（对象）被称作闭包（closure）。该名称源于“捕获”其自由变量从而“闭合”该函数字面量的动作。没有自由变量的函数字面量，比如 (x: Int) => x + 1,称为闭合语（closed term），这里的语（term）指的是一段源代码。
   
   而运行时从任何带有自由变量的函数字面量，比如 (x: Int) => x + more，创建的函数值，按照定义，要求捕获到它的自由变量 more 的绑定。相应的函数值结果（包含指向被捕获的 more 变量的引用）就被称为闭包，因为函数值是通过闭合这个开放语（open term）的动作产生的。

   这个例子带来一个问题，如果 more 在闭包创建以后被改变会发生什么？在 scala 中，答案是闭包能够看到这个改变。Scala 的闭包捕获的是变量本身，而不是变量引用的值。反过来也成立，闭包对捕获到的变量的修改也能在闭包外被看到。
   #+begin_src scala
     var more = 1
     val addMore = (x: Int) => x + more
     addMore(10)

     more = 9999
     addMore(10)


     val someNumbers = List(-11, -10, -5, 0, 5, 10)
     var sum = 0
     some
   #+end_src

   #+RESULTS:
   : more: Int = 1
   : addMore: Int => Int = <function1>
   : res18: Int = 11
   : more: Int = 9999
   : res19: Int = 10009
   : someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
   : sum: Int = 0
   : res21: Int = -11

** 特殊的函数调用形式
   Scala 支持重复参数，带名字的参数和缺省参数
   
*** 重复参数
    Scala 允许你标识出函数的最后一个参数可以被重复。这让我们可以对函数传入一个可变长度的参数列表。要标识这样一个重复参数，需要在参数的类型之后加上一个星号（*）。

    #+begin_src scala
      def echo(args: String*) = for (arg <- args) println(arg)

      val arr = Array("What's", "up", "doc?")
      echo(arr) // error: type mismatch

      echo(arr: _*)
    #+end_src

    #+RESULTS:
    #+begin_example
    echo: (args: String*)Unit
    arr: Array[String] = Array(What's, up, doc?)
    /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evaluEoZU5:14: error: type mismatch;
     found   : Array[String]
     required: String
           echo(arr) // error: type mismatch
                ^
    What's
    up
    doc?
    #+end_example
*** 带名字的参数
    #+begin_src scala
      def speed(distance: Float, time: Float) =
          distance / time
    #+end_src

    #+RESULTS:
    : speed: (distance: Float, time: Float)Float

*** 缺省参数值
    #+begin_src scala
      def printTime(out: java.io.PrintStream = Console.out) = out.println("time=" + System.currentTimeMillis())
    #+end_src

    #+RESULTS:
    : printTime: (out: java.io.PrintStream)Unit

** 尾递归
   Scala 编译器能够执行一个重要的优化。函数体在求值过程中最后一步调用自己的函数，被称为尾递归（tail recursive）函数。Scala 能够检测到尾递归并将它替换成跳转到函数的最开始，并在跳转之前将参数更新为新的值。

   这背后的意思是我们不应该回避使用递归算法来解决问题。通常，递归算法比基于循环的算法更优雅，精简。如果解决方案是尾递归的，那么我们并不需要支付任何（额外的）运行开销。

   #+begin_src scala
     def approximate(guess: Double): Double =
       if (isGoodEnough(guess)) guess
       else approximate(improve(guess))
   #+end_src


*** 跟踪尾递归函数
    尾递归函数并不会在每次调用时构建一个新的栈桢，所有的调用都会在同一个栈桢中执行。
    
*** 尾递归的局限
    两个相互递归的函数，Scala 没法优化它们。

    如果最调用的是一个函数值（而不是发起调用的那个函数自己），也无法享受到尾递归优化。
    
    #+begin_src scala
      def isEven(x: Int): Boolean =
        if (x == 0) true else isOdd(x - 1)
      def isOdd(x: Int): Boolean =
        if (x == 0) false else isEven(x - 1)


      val funValue = nestedFun _
      def nestedFun(x: Int): Unit = {
        if (x != 0) {println(x); funValue(x - 1)}
      }
    #+end_src

    尾递归优化仅适用于某个方法或嵌套函数在最后一步操作用调用自己，并且没有经过函数值或者其他中间环节的场合。

* 第九章 控制抽象

** 减少代码重复
   高阶函数（higher-order function），即那些接收函数作为参数的函数，让你有额外的机会来进一步压缩和简化代码。

   高阶函数的好处之一是可以用来创建减少代码重复的控制抽象。
    
   #+begin_src scala
     def filesHere = (new java.io.File(".")).listFiles
     def filesMatching(query: String, matcher:(String, String)=>Boolean ) = {
       for (file <- filesHere; if matcher(file.getName, query))
       yield file
     }

     def filesEnding(query: String) =
       /** (file: String, query: String) => fileName.endsWith(query)
           由于 file，query 只使用了一次，所以可以直接用 _ 代替，然后由于 matcher 的入参类型明显可知，所以入参可以省略，所以得到 _.endsWith(_)
       **/
       filesMatching(query, _.endsWith(_))

     def filesContaining(query: String) =
       filesMatching(query, _.contains(_))

     def filesRegex(query: String) =
       filesMatching(query, _.matches(_))
   #+end_src

   #+RESULTS:
   : filesHere: Array[java.io.File]
   : filesMatching: (query: String, matcher: (String, String) => Boolean)Array[java.io.File]
   : filesEnding: (query: String)Array[java.io.File]
   : filesContaining: (query: String)Array[java.io.File]
   : filesRegex: (query: String)Array[java.io.File]

   代码利用闭包还可以更短。
   #+begin_src scala
     object FileMatcher {
       private def filesHere = (new java.io.File(".")).listFiles
       private def filesMatching(matcher: String =>Boolean ) = {
         for (file <- filesHere; if matcher(file.getName))
         yield file
       }

       def filesEnding(query: String) =
         filesMatching(_.endsWith(query))

       def filesContaining(query: String) =
         filesMatching(_.contains(query))

       def filesRegex(query: String) =
         filesMatching(_.matches(query))
     }
   #+end_src

   #+RESULTS:
   : defined object FileMatcher

** 简化调用方代码 略
** 柯里化（currying）
   #+begin_src scala

   #+end_src



