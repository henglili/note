
* 第二章 Scala 入门
** 定义变量
   val：一旦初始化不能被重新赋值。
   var

   Scala 并不是在变量名之前给出类型，而是在变量名之后，变量名和类型之间使用分号（:）隔开。
** 定义函数
   #+begin_src scala
     def max(x: Int, y: Int): Int = {
       if (x > y)
         x
       else
         y
     }
     max(1,2)
   #+end_src

   #+RESULTS:
   : max: (x: Int, y: Int)Int
   : res6: Int = 2
   
   函数体之前的等号也有特别的含义，表示在函数式的世界观里，函数定义的是一个可以获取到结果值的表达式。

   如果函数是递归的，必须显示地给出函数的结果类型。

   如果函数只有一条语句，也可以选择不使用花括号。

** 用 while 做循环；用 if 做判断
   #+begin_src scala
     var i = 0
     val l = List("scala", "is", "fun")
     while (i < l.length){
       println(l(i))
       i += 1
     }
   #+end_src
   
   #+RESULTS:
   : i: Int = 0
   : l: List[String] = List(scala, is, fun)
   : scala
   : is
   : fun
   
   Java 中的 i++ 和 ++i 在 Scala 中并不工作

   Scala 中 while 或 if 语句中的 boolean 表达式必须放在圆括号里。如果 if 代码块只有单个语句，可以选择不写花括号。这点和 Java 是一样的。

   这并不是最佳的 scala 风格。
   
** 使用 foreach 和 for 遍历
   当你写下 while 循环时，实际上是在以指令式（imperative）的风格编程。指令时风格也是类似 Java，C++，C 这样的语言通常的风格，依次给出执行指令，通过循环来遍历，而且还经常变更被不同函数共享的状态。Scala 允许以指令式风格编程，不过随着你对 Scala 的了解日益加深，你应该更倾向于使用更加函数式（functional）的风格。

   函数式编程语言的主要特征之一就是函数是一等的语法单元。例如：
   #+begin_src scala
     val l = List("Concise", "is", "nice")
     l.foreach(arg => println(arg))
   #+end_src

   #+RESULTS:
   : l: List[String] = List(Concise, is, nice)
   : Concise
   : is
   : nice

   foreach 方法传入的是一个函数字面量（function literal）。

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/函数字面量语法.png]]
   

   如果函数字面量只是一个可以接收单个参数的语句，可以不必给出参数名和参数本身。这个简写规则用到的特性叫作部分应用函数（partially applied function），在 8.6 节会有详细介绍。
   #+begin_src scala
     val l = List("Concise", "is", "nice")
     l.foreach(println)
   #+end_src

   #+RESULTS:
   : l: List[String] = List(Concise, is, nice)
   : Concise
   : is
   : nice


   #+begin_src scala
     val l = List("for", "arg", "in", "args")
     for(arg <- l)
       println(arg)
   #+end_src

   #+RESULTS:
   : l: List[String] = List(for, arg, in, args)
   : for
   : arg
   : in
   : args
   
   在 <- 符合左边的 arg 是一个 val 变量。对于 args 中的每一个元素，一个新的名为 arg 的 val 会被创建出来。


* 第三章 Scala 入门（续）
** 用类型参数化（parameterize）数组
   参数化的意思是，在创建实例时对实例做“配置”。比如使用 new 来实例化对象时，可以用值和类型来对其进行参数化。

   注意，当你使用类型和值来参数化一个实例时，先是方括号包起来的类型（参数），然后才是用圆括号包起来的值（参数）。

   类型参数（方括号包起来的类型名称）是该实例类型的一部分，但值参数（圆括号包起来的值）并不是。
   
   #+begin_src scala
     val greetStrings = new Array[String](3)
     greetStrings(0) = "Hello"
     greetStrings(1) = ", "
     greetStrings(2) = "world!\n"
     for(i <- 0 to 2)
       print(greetStrings(i))

     // 也可以显示的给出 greetStrings 的类型
     val greetStrings: Array[String] = new Array[String](3)
   #+end_src

   #+RESULTS:
   : greetStrings: Array[String] = Array(null, null, null)
   : Hello, world!
   : greetStrings: Array[String] = Array(null, null, null)

   这个例子展示了 Scala 关于 val 的一个重要概念。当你用 val 定义一个变量时，变量本身不能被重新赋值，但是它指向的那个对象是可能发生改变的。数组本身是可变的。

   for 表达式的第一行展示了 Scala 的另一个通行规则：如果一个方法只接收一个参数，在调用它的时候，可以不使用英文句点或圆括号。例如：0 to 2 会被转换为 (0).to(2)

   Scala 从技术上将并没有操作符重载（operator overloading），因为它实际上并没有传统意义上的操作符。类似 + ，-，*，/ 这样的字符可以被用作方法名。例如：1 + 2 是 (1).+(2)

   另外一个重要理念是为什么 Scala 用圆括号（而不是方括号）来访问数组。跟 Java 比起来 Scala 特例更少。数组不过是类的实例，这一点跟其他 Scala 实例没有本质区别。当你用一组圆括号将一个或多个值包装起来，并将其应用（apply）到某个对象时，Scala 会将这段代码转换成对这个对象的一个名为 apply 的方法的调用。访问数组的一个元素就是一个简单的方法调用。当然，这仅对在对象的类型实际上定义了 apply 方法是才能编译通过。因此，这并不是一个特例，而是一个通行规则。

   同理，当我们尝试对通过圆括号应用了一个或多个参数的变量进行赋值时，编译器会将代码转换成对 update 方法的调用。
   
   #+begin_src scala

// Scala 创建并初始化数组的推荐做法
val numName = Array("zero", "one", "two")

   #+end_src

   #+RESULTS:
   : numName: Array[String] = Array(zero, one, two)

   这个例子，实际上是调用了一个名为 apply 的工厂方法，这个方法创建并返回了新的数组。该方法定义在 Array 的伴生对象（companion object）中。
** 使用列表
   函数式编程的重要概念之一是方法不能有副作用。这样做的好处是方法不再相互纠缠在一起，因此变得更可靠，更易复用。另一个好处（作为静态类型的编程语言）是类型检查器会检查方法的入参和出参，因此逻辑错误通常都是以类型错误的形式出现。将这个函数式的哲学应用到对象的世界意味着让对象不可变。

   Scala 的 List 是不可变的。
   #+begin_src scala
     val twoThree = List(2, 3)
     val oneTwoThree = 1 :: twoThree
     println(oneTwoThree)
   #+end_src

   #+RESULTS:
   : twoThree: List[Int] = List(2, 3)
   : oneTwoThree: List[Int] = List(1, 2, 3)
   : List(1, 2, 3)

   注意 :: 是右操作元（right operand，即 twoThree 这个列表的方法）。背后的规则是，如果一个方法被用到操作符表示法（operator notation）中时，调用默认发生在左操作元（left operand），除非方法名以冒号（:）结尾。

   空列表的快捷表示为 Nil。

   为什么不在列表末尾追加元素？List 类提供了追加操作（:+），但是很少被使用，因为往列表末尾追加元素的操作所需要的时间随列表的大小线性增加，而使用 :: 在列表前面添加元素只需要常量时间。如果想通过追加元素的方式高效地构建列表，可以依次在头部添加完成后，在调用 reverse。也可以使用 ListBuffer，这是个可变列表，支持追加操作，完成后调用 toList 即可。
   #+begin_src scala
     // 列表的一些常用方法
     List()
     Nil
     List("Cool", "tools", "rule")
     val thrill = "Will" :: "fill" :: "util" :: Nil
     List("a", "b") ::: List("c", "d")
     thrill(2)
     thrill.count(s => s.length == 4)
     // 去掉头两个元素
     thrill.drop(2)
     // 去掉末尾两个元素
     thrill.dropRight(2)
     thrill.exists(s => s == "util")
     thrill.filter(s => s.length == 4)
     thrill.forall(s => s.endsWith("l"))
     thrill.foreach(s => println(s))
     thrill.foreach(println)
     // 返回头一个元素
     thrill.head
     // 返回除最后一个元素以外的其他元素组成的列表。
     thrill.init
     thrill.isEmpty
     // 返回最后一个元素
     thrill.last
     thrill.length
     thrill.map(s => s + "y")
     thrill.mkString(", ")
     thrill.filterNot(s => s.length == 4)
     thrill.reverse
     // thrill.sort((s,t) => s.charAt(0).toLower < t.charAt(0).toLower)
     // 返回除头一个元素以外的其它元素组成的列表
     thrill.tail
   #+end_src

   #+RESULTS:
   #+begin_example
   res128: List[Nothing] = List()
   res129: scala.collection.immutable.Nil.type = List()
   res130: List[String] = List(Cool, tools, rule)
   thrill: List[String] = List(Will, fill, util)
   res131: List[String] = List(a, b, c, d)
   res132: String = util
   res133: Int = 3
   res134: List[String] = List(util)
   res135: List[String] = List(Will)
   res136: Boolean = true
   res137: List[String] = List(Will, fill, util)
   res138: Boolean = true
   Will
   fill
   util
   Will
   fill
   util
   res141: String = Will
   res142: List[String] = List(Will, fill)
   res143: Boolean = false
   res144: String = util
   res145: Int = 3
   res146: List[String] = List(Willy, filly, utily)
   res147: String = Will, fill, util
   res148: List[String] = List()
   res149: List[String] = List(util, fill, Will)
   res150: List[String] = List(fill, util)
   #+end_example

** 使用元组
   元组也是不可变的，元组可以容纳不同类型。一旦实例好一个元组，可以使用英文句点，下划线和从 1 开始的序号来访问每一个元素。

   #+begin_src scala
     val pair = (99, "Luftballons")
     println(pair._1)
     println(pair._2)
   #+end_src

   #+RESULTS:
   : pair: (Int, String) = (99,Luftballons)
   : 99
   : Luftballons

   为什么不能像访问列表元素那样访问元组元素。背后的原因是列表的 apply 方法永远只返回同一种类型，但元组里的元素可以是不同类型的。_1 可能是一种类型，_2 可能是另一种类型。目前 Scala 标准库只支持到 Tuple22 （即包含 22 个元素的元组）。

** 使用集和映射

   集合类库特意对可变和不可变的集合进行了区分。默认创建一个不可变集。如果需要可变的，要做一次 import。

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/set的类继承关系.png]]

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/map的类继承关系.png]]

   #+begin_src scala
     var jetSet = Set("Boeing", "Airbus")
     jetSet += "Lear"
     println(jetSet.contains("Cessna"))
   #+end_src

   #+RESULTS:
   : jetSet: scala.collection.immutable.Set[String] = Set(Boeing, Airbus)
   : false

   注意第二行，"jetSet += "Lear"" 本质上是 jetSet = jetSet + "Lear" 的简写。

   "+" 方法会创建一个并返回一个包含新元素的 Set。所以 jetSet 定义时要使用 var，因为重新进行了赋值。
    
   #+begin_src scala
     import scala.collection.mutable
     val movieSet = mutable.Set("Hitch", "Poltergeist")
     movieSet += "Shrek"
     println(movieSet)
   #+end_src

   #+RESULTS:
   : import scala.collection.mutable
   : movieSet: scala.collection.mutable.Set[String] = Set(Poltergeist, Hitch)
   : res9: movieSet.type = Set(Poltergeist, Shrek, Hitch)
   : Set(Poltergeist, Shrek, Hitch)

   第三行的 += 实际上是定义在可变 Set 上的方法。

   #+begin_src scala
     val romanNumeral = Map(1 -> "I", 2 -> "II", 3 -> "III", 4 -> "IV", 5 -> "V")
     println(romanNumeral)
   #+end_src

   #+RESULTS:
   : romanNumeral: scala.collection.immutable.Map[Int,String] = Map(5 -> V, 1 -> I, 2 -> II, 3 -> III, 4 -> IV)
   : Map(5 -> V, 1 -> I, 2 -> II, 3 -> III, 4 -> IV)

   -> 也是方法
   
   #+begin_src scala
     import scala.collection.mutable

     val treasureMap = mutable.Map[Int, String]()
     treasureMap += (1 -> "Go to island.")
     treasureMap += (2 -> "Find big X on ground.")
     treasureMap += (3 -> "Dig.")
     println(treasureMap(2))
   #+end_src

   #+RESULTS:
   : import scala.collection.mutable
   : treasureMap: scala.collection.mutable.Map[Int,String] = Map()
   : res14: treasureMap.type = Map(1 -> Go to island.)
   : res15: treasureMap.type = Map(2 -> Find big X on ground., 1 -> Go to island.)
   : res16: treasureMap.type = Map(2 -> Find big X on ground., 1 -> Go to island., 3 -> Dig.)
   : Find big X on ground.

** 识别函数式编程风格
   scala 更偏向于使用 val 。
   
   #+begin_src scala
     def printArgs(args: Array[String]): Unit = {
       var i = 0
       while(i < args.length) {
         println(args(i))
         i += 1
       }
     }

     // 去掉 var
     def printArgs(args: Array[String]): Unit = {
       for(arg <- args)
         println(arg)
     }

     // 或者
     def printArgs(args: Array[String]): Unit = {
       args.foreach(println)
     }

   #+end_src

   #+RESULTS:
   : printArgs: (args: Array[String])Unit
   : printArgs: (args: Array[String])Unit
   : printArgs: (args: Array[String])Unit

   重构后的方法依然不是 ”纯“ 的函数式代码，因为它有副作用（本例中它的副作用是像标准输出流打印）。带有副作用的函数的标志性特征是结果类型为 Unit。如果一个函数不返回任何有意义的值，也就是 Unit 这样的结果类型所表达的意思，那么这个函数存在于世上唯一的意义就是产生某种副作用。
   
   #+begin_src scala
     def formatArgs(args: Array[String]) = args.mkString("\n")
   #+end_src

   #+RESULTS:
   : formatArgs: (args: Array[String])String

   scala 是指令式/函数式混合（hybrid）编程语言，你会发现有些场景下对于要解决的问题而言指令式更为合适，这个时候不要犹豫，使用指令式的风格就好。

* 第四章 类和对象
** 类，字段和方法
   #+begin_src scala
     class ChecksumAccumulator{
       // 这里是类定义
     }
   #+end_src
   在类定义中，你会填入字段（field）和方法（method），这些被统称为成员（member）。字段保留了对象的状态，或者说数据，而方法用这些数据来对对象执行计算。
   
   字段又叫做实例变量（instance variable），因为每个实例都有自己的变量。

   追求健壮性的一个重要手段是确保对象的状态（它的实例变量的值）在其整个声明周期都是有效的。首先是通过将字段标记为私有（private）来防止外部直接访问字段。在 Scala 中，使得成员允许公共访问（public）的方式是不再成员前面显示地给出任何访问修饰符。

   Scala 方法参数的一个重要特征是它们都是 val 而不是 var。所有方法都是，不光是类中的方法。

   在没有任何显示的 return 语句时，Scala 方法返回的是该方法计算出的最后一个（表达式的）值。实际上推荐的风格是避免使用任何显示的 return 语句，尤其是多个 return 语句。与此相反，尽量将每个方法当作是一个最终交出某个值的表达式。这样的哲学鼓励你编写短小的方法，将大的方法拆成小的。另一方面，设计中的选择也是取决于上下文的，Scala 也允许你方便地编写有多个显示 return 的方法，如果那确实是你想要的。

   #+begin_src scala
     class ChecksumAccumulator {
       private var sum = 0
       def add(b: Byte) = sum += b
       def checksum() = ~(sum & 0xFF) + 1
     }

     /** 虽然 Scala 能够正确推到出 add 和 checksum 这两个方法的结果类型，
     但是代码的读者需要在脑海里推断（mentally infer）这些结果类型。
     所以，通常更好的做法是对类中声明为公有的方法显示地给出结果类型。
     ,**/

     class ChecksumAccumulator {
       private var sum = 0
       def add(b: Byte): Unit = {sum += b}
       def checksum(): Int = ~(sum & 0xFF) + 1
     }
   #+end_src

   #+RESULTS:
   : defined class ChecksumAccumulator
   : defined class ChecksumAccumulator
   
   结果类型为 Unit 的方法， 如 add 方法，执行的目的是为了它们的副作用。副作用通常来说指的是改变方法外部的某种状态或执行 I/O 的动作。就 add 而言，其副作用就是给 sum 重新赋值。

   那些仅仅因为其副作用而被执行的方法被称作过程（procedure）。

** 分号推断
   在 Scala 程序中，每条语句最后的分号通常是可选的。如果想要一条跨多行的语句，大多数情况下直接换行即可，比如：if-else。不过偶尔 Scala 也会背离你的意图，在不该断句的地方断句：
   #+begin_src scala
     x
     + y
   #+end_src
   
   这段代码会被解析成 x 和 +y。解决办法，当用中缀（infix）操作符比如 + 来串接表达式时，一个常见的 Scala 风格是将操作符放在行尾而不是行首：
   #+begin_src scala
     x +
     y +
     z
   #+end_src

   分号推理规则：

   概括的说，除非以下任何一条为 true，代码行的末尾就会被当作分号处理：

   1. 当前行以一个不能作为语句结尾的词结尾，比如英文句点或中缀操作符。

   2. 下一行以一个不能作为语句开头的词开头

   3. 当前行的行尾出现在圆括号（...）或方括号 [...] 内，因为再怎么说圆括号和方括号也不能（直接）包含多条语句。

** 单例对象
   Scala 比 Java 更面向对象一点，是 Scala 的类不允许有静态（static）成员。对此类使用场景，Scala 提供了单例对象（singleton object）。单例对象的定义看上去跟类定义很像，只不过 class 关键字被换成了 object 关键字。

   当单例对象跟某个类公用同一个名字是，它被称作这个类的伴生对象（companion object）。必须在同一个源文件中定义类和类的伴生对象。同时，类又叫作这个单例对象的伴生类（companion class）。类和它的伴生对象可以互相访问对方的私有成员。
   #+begin_src scala
     import scala.collection.mutable
     object ChecksumAccumulator {
       private val cache = mutable.Map.empty[String, Int]
       def calculate(s: String): Int =
         if (cache.contains(s))
           cache(s)
         else {
           val acc = new ChecksumAccumulator
           for(c <- s)
             acc.add(c.toByte)
           val cs = acc.checksum()
           cache += (s -> cs)
           cs
         }
     }

     class ChecksumAccumulator {
       private var sum = 0
       def add(b: Byte): Unit = {sum += b}
       def checksum(): Int = ~(sum & 0xFF) + 1
     }
   #+end_src

   单例对象并不仅仅是用来存放静态方法，它是一等的对象。意味着：可以被存入变数或其他结构；可以被作为参数传递给其他函数；可以被作为函数的返回值；可以在执行期创造，而无需完全在设计期全部写出；即使没有被系结至某以名称，也可以存在。

   定义单例对象并不会定义类型（在 Scala 的抽象层级上是这样）。

   类和单例对象的一个区别是单例对象不能接收参数，而类可以。每个单例对象都是通过一个静态变量引用合成类（synthetic class）的实例来实现的，因此单例对象从初始化的语义上跟 Java 的静态成员是一致的。尤其体现在，单例对象在有代码访问时才被初始化。

   没有同名的伴生类的单例对象称为孤立对象（standalone object）。
** Scala 应用程序
   要运行一个 Scala 程序，必须提供一个独立对象的名称。这个独立对象需要包含一个 main 方法，该方法接收一个 Array[String] 作为参数，结果类型为 Unit。任何带有满足正确签名的 main 方法的独立对象都能被用作应用程序的入口。
   
   Scala 在每一个 Scala 源码文件中都隐式地引入了 java.lang 和 scala 包的成员，以及名为 Predef 的单例对象的所有成员。
   
   Scala 和 Java 的区别之一，是 Java 要求你将公共的类放入跟类同名的文件中，而在 Scala 中可以任意命名 .scala 文件，不论你放什么类或代码到这个文件中。不过，通常对于那些非脚本的场景，把类放入以类名命名的文件是推荐的做法，就像 Java 那样。 

** App 特质

   Scala 提供了一个特质 scala.App，帮助你节省敲键盘的动作。
   
   #+begin_src scala
     object summer extends App {
       println("extend App")
     }

   #+end_src

   #+RESULTS:
   : defined object summer

   要使用这个特质，首先要在你的单例对象名后加上 "extends App"。然后，并不是直接编写 main 方法，而是将你打算放在 main 方法里的代码直接写在单例对象的花括号中。可以通过名为 args 的字符串数组来访问命令行参数。

* 第五章 基础类型和操作

