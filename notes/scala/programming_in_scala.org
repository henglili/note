
* 第二章 Scala 入门
** 定义变量
   val：一旦初始化不能被重新赋值。
   var

   Scala 并不是在变量名之前给出类型，而是在变量名之后，变量名和类型之间使用分号（:）隔开。
** 定义函数
   #+begin_src scala
     def max(x: Int, y: Int): Int = {
       if (x > y)
         x
       else
         y
     }
     max(1,2)
   #+end_src

   #+RESULTS:
   : max: (x: Int, y: Int)Int
   : res6: Int = 2
   
   函数体之前的等号也有特别的含义，表示在函数式的世界观里，函数定义的是一个可以获取到结果值的表达式。

   如果函数是递归的，必须显示地给出函数的结果类型。

   如果函数只有一条语句，也可以选择不使用花括号。

** 用 while 做循环；用 if 做判断
   #+begin_src scala
     var i = 0
     val l = List("scala", "is", "fun")
     while (i < l.length){
       println(l(i))
       i += 1
     }
   #+end_src
   
   #+RESULTS:
   : i: Int = 0
   : l: List[String] = List(scala, is, fun)
   : scala
   : is
   : fun
   
   Java 中的 i++ 和 ++i 在 Scala 中并不工作

   Scala 中 while 或 if 语句中的 boolean 表达式必须放在圆括号里。如果 if 代码块只有单个语句，可以选择不写花括号。这点和 Java 是一样的。

   这并不是最佳的 scala 风格。
   
** 使用 foreach 和 for 遍历
   当你写下 while 循环时，实际上是在以指令式（imperative）的风格编程。指令时风格也是类似 Java，C++，C 这样的语言通常的风格，依次给出执行指令，通过循环来遍历，而且还经常变更被不同函数共享的状态。Scala 允许以指令式风格编程，不过随着你对 Scala 的了解日益加深，你应该更倾向于使用更加函数式（functional）的风格。

   函数式编程语言的主要特征之一就是函数是一等的语法单元。例如：
   #+begin_src scala
     val l = List("Concise", "is", "nice")
     l.foreach(arg => println(arg))
   #+end_src

   #+RESULTS:
   : l: List[String] = List(Concise, is, nice)
   : Concise
   : is
   : nice

   foreach 方法传入的是一个函数字面量（function literal）。

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/函数字面量语法.png]]
   

   如果函数字面量只是一个可以接收单个参数的语句，可以不必给出参数名和参数本身。这个简写规则用到的特性叫作部分应用函数（partially applied function），在 8.6 节会有详细介绍。
   #+begin_src scala
     val l = List("Concise", "is", "nice")
     l.foreach(println)
   #+end_src

   #+RESULTS:
   : l: List[String] = List(Concise, is, nice)
   : Concise
   : is
   : nice


   #+begin_src scala
     val l = List("for", "arg", "in", "args")
     for(arg <- l)
       println(arg)
   #+end_src

   #+RESULTS:
   : l: List[String] = List(for, arg, in, args)
   : for
   : arg
   : in
   : args
   
   在 <- 符合左边的 arg 是一个 val 变量。对于 args 中的每一个元素，一个新的名为 arg 的 val 会被创建出来。


* 第三章 Scala 入门（续）
** 用类型参数化（parameterize）数组
   参数化的意思是，在创建实例时对实例做“配置”。比如使用 new 来实例化对象时，可以用值和类型来对其进行参数化。

   注意，当你使用类型和值来参数化一个实例时，先是方括号包起来的类型（参数），然后才是用圆括号包起来的值（参数）。

   类型参数（方括号包起来的类型名称）是该实例类型的一部分，但值参数（圆括号包起来的值）并不是。
   
   #+begin_src scala
     val greetStrings = new Array[String](3)
     greetStrings(0) = "Hello"
     greetStrings(1) = ", "
     greetStrings(2) = "world!\n"
     for(i <- 0 to 2)
       print(greetStrings(i))

     // 也可以显示的给出 greetStrings 的类型
     val greetStrings: Array[String] = new Array[String](3)
   #+end_src

   #+RESULTS:
   : greetStrings: Array[String] = Array(null, null, null)
   : Hello, world!
   : greetStrings: Array[String] = Array(null, null, null)

   这个例子展示了 Scala 关于 val 的一个重要概念。当你用 val 定义一个变量时，变量本身不能被重新赋值，但是它指向的那个对象是可能发生改变的。数组本身是可变的。

   for 表达式的第一行展示了 Scala 的另一个通行规则：如果一个方法只接收一个参数，在调用它的时候，可以不使用英文句点或圆括号。例如：0 to 2 会被转换为 (0).to(2)

   Scala 从技术上将并没有操作符重载（operator overloading），因为它实际上并没有传统意义上的操作符。类似 + ，-，*，/ 这样的字符可以被用作方法名。例如：1 + 2 是 (1).+(2)

   另外一个重要理念是为什么 Scala 用圆括号（而不是方括号）来访问数组。跟 Java 比起来 Scala 特例更少。数组不过是类的实例，这一点跟其他 Scala 实例没有本质区别。当你用一组圆括号将一个或多个值包装起来，并将其应用（apply）到某个对象时，Scala 会将这段代码转换成对这个对象的一个名为 apply 的方法的调用。访问数组的一个元素就是一个简单的方法调用。当然，这仅对在对象的类型实际上定义了 apply 方法是才能编译通过。因此，这并不是一个特例，而是一个通行规则。

   同理，当我们尝试对通过圆括号应用了一个或多个参数的变量进行赋值时，编译器会将代码转换成对 update 方法的调用。
   
   #+begin_src scala

// Scala 创建并初始化数组的推荐做法
val numName = Array("zero", "one", "two")

   #+end_src

   #+RESULTS:
   : numName: Array[String] = Array(zero, one, two)

   这个例子，实际上是调用了一个名为 apply 的工厂方法，这个方法创建并返回了新的数组。该方法定义在 Array 的伴生对象（companion object）中。
** 使用列表
   函数式编程的重要概念之一是方法不能有副作用。这样做的好处是方法不再相互纠缠在一起，因此变得更可靠，更易复用。另一个好处（作为静态类型的编程语言）是类型检查器会检查方法的入参和出参，因此逻辑错误通常都是以类型错误的形式出现。将这个函数式的哲学应用到对象的世界意味着让对象不可变。

   Scala 的 List 是不可变的。
   #+begin_src scala
     val twoThree = List(2, 3)
     val oneTwoThree = 1 :: twoThree
     println(oneTwoThree)
   #+end_src

   #+RESULTS:
   : twoThree: List[Int] = List(2, 3)
   : oneTwoThree: List[Int] = List(1, 2, 3)
   : List(1, 2, 3)

   注意 :: 是右操作元（right operand，即 twoThree 这个列表的方法）。背后的规则是，如果一个方法被用到操作符表示法（operator notation）中时，调用默认发生在左操作元（left operand），除非方法名以冒号（:）结尾。

   空列表的快捷表示为 Nil。

   为什么不在列表末尾追加元素？List 类提供了追加操作（:+），但是很少被使用，因为往列表末尾追加元素的操作所需要的时间随列表的大小线性增加，而使用 :: 在列表前面添加元素只需要常量时间。如果想通过追加元素的方式高效地构建列表，可以依次在头部添加完成后，在调用 reverse。也可以使用 ListBuffer，这是个可变列表，支持追加操作，完成后调用 toList 即可。
   #+begin_src scala
     // 列表的一些常用方法
     List()
     Nil
     List("Cool", "tools", "rule")
     val thrill = "Will" :: "fill" :: "util" :: Nil
     List("a", "b") ::: List("c", "d")
     thrill(2)
     thrill.count(s => s.length == 4)
     // 去掉头两个元素
     thrill.drop(2)
     // 去掉末尾两个元素
     thrill.dropRight(2)
     thrill.exists(s => s == "util")
     thrill.filter(s => s.length == 4)
     thrill.forall(s => s.endsWith("l"))
     thrill.foreach(s => println(s))
     thrill.foreach(println)
     // 返回头一个元素
     thrill.head
     // 返回除最后一个元素以外的其他元素组成的列表。
     thrill.init
     thrill.isEmpty
     // 返回最后一个元素
     thrill.last
     thrill.length
     thrill.map(s => s + "y")
     thrill.mkString(", ")
     thrill.filterNot(s => s.length == 4)
     thrill.reverse
     // thrill.sort((s,t) => s.charAt(0).toLower < t.charAt(0).toLower)
     // 返回除头一个元素以外的其它元素组成的列表
     thrill.tail
   #+end_src

   #+RESULTS:
   #+begin_example
   res128: List[Nothing] = List()
   res129: scala.collection.immutable.Nil.type = List()
   res130: List[String] = List(Cool, tools, rule)
   thrill: List[String] = List(Will, fill, util)
   res131: List[String] = List(a, b, c, d)
   res132: String = util
   res133: Int = 3
   res134: List[String] = List(util)
   res135: List[String] = List(Will)
   res136: Boolean = true
   res137: List[String] = List(Will, fill, util)
   res138: Boolean = true
   Will
   fill
   util
   Will
   fill
   util
   res141: String = Will
   res142: List[String] = List(Will, fill)
   res143: Boolean = false
   res144: String = util
   res145: Int = 3
   res146: List[String] = List(Willy, filly, utily)
   res147: String = Will, fill, util
   res148: List[String] = List()
   res149: List[String] = List(util, fill, Will)
   res150: List[String] = List(fill, util)
   #+end_example

** 使用元组
   元组也是不可变的，元组可以容纳不同类型。一旦实例好一个元组，可以使用英文句点，下划线和从 1 开始的序号来访问每一个元素。

   #+begin_src scala
     val pair = (99, "Luftballons")
     println(pair._1)
     println(pair._2)
   #+end_src

   #+RESULTS:
   : pair: (Int, String) = (99,Luftballons)
   : 99
   : Luftballons

   为什么不能像访问列表元素那样访问元组元素。背后的原因是列表的 apply 方法永远只返回同一种类型，但元组里的元素可以是不同类型的。_1 可能是一种类型，_2 可能是另一种类型。目前 Scala 标准库只支持到 Tuple22 （即包含 22 个元素的元组）。

** 使用集和映射

   集合类库特意对可变和不可变的集合进行了区分。默认创建一个不可变集。如果需要可变的，要做一次 import。

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/set的类继承关系.png]]

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/map的类继承关系.png]]

   #+begin_src scala
     var jetSet = Set("Boeing", "Airbus")
     jetSet += "Lear"
     println(jetSet.contains("Cessna"))
   #+end_src

   #+RESULTS:
   : jetSet: scala.collection.immutable.Set[String] = Set(Boeing, Airbus)
   : false

   注意第二行，"jetSet += "Lear"" 本质上是 jetSet = jetSet + "Lear" 的简写。

   "+" 方法会创建一个并返回一个包含新元素的 Set。所以 jetSet 定义时要使用 var，因为重新进行了赋值。
    
   #+begin_src scala
     import scala.collection.mutable
     val movieSet = mutable.Set("Hitch", "Poltergeist")
     movieSet += "Shrek"
     println(movieSet)
   #+end_src

   #+RESULTS:
   : import scala.collection.mutable
   : movieSet: scala.collection.mutable.Set[String] = Set(Poltergeist, Hitch)
   : res9: movieSet.type = Set(Poltergeist, Shrek, Hitch)
   : Set(Poltergeist, Shrek, Hitch)

   第三行的 += 实际上是定义在可变 Set 上的方法。

   #+begin_src scala
     val romanNumeral = Map(1 -> "I", 2 -> "II", 3 -> "III", 4 -> "IV", 5 -> "V")
     println(romanNumeral)
   #+end_src

   #+RESULTS:
   : romanNumeral: scala.collection.immutable.Map[Int,String] = Map(5 -> V, 1 -> I, 2 -> II, 3 -> III, 4 -> IV)
   : Map(5 -> V, 1 -> I, 2 -> II, 3 -> III, 4 -> IV)

   -> 也是方法
   
   #+begin_src scala
     import scala.collection.mutable

     val treasureMap = mutable.Map[Int, String]()
     treasureMap += (1 -> "Go to island.")
     treasureMap += (2 -> "Find big X on ground.")
     treasureMap += (3 -> "Dig.")
     println(treasureMap(2))
   #+end_src

   #+RESULTS:
   : import scala.collection.mutable
   : treasureMap: scala.collection.mutable.Map[Int,String] = Map()
   : res14: treasureMap.type = Map(1 -> Go to island.)
   : res15: treasureMap.type = Map(2 -> Find big X on ground., 1 -> Go to island.)
   : res16: treasureMap.type = Map(2 -> Find big X on ground., 1 -> Go to island., 3 -> Dig.)
   : Find big X on ground.

** 识别函数式编程风格
   scala 更偏向于使用 val 。
   
   #+begin_src scala
     def printArgs(args: Array[String]): Unit = {
       var i = 0
       while(i < args.length) {
         println(args(i))
         i += 1
       }
     }

     // 去掉 var
     def printArgs(args: Array[String]): Unit = {
       for(arg <- args)
         println(arg)
     }

     // 或者
     def printArgs(args: Array[String]): Unit = {
       args.foreach(println)
     }

   #+end_src

   #+RESULTS:
   : printArgs: (args: Array[String])Unit
   : printArgs: (args: Array[String])Unit
   : printArgs: (args: Array[String])Unit

   重构后的方法依然不是 ”纯“ 的函数式代码，因为它有副作用（本例中它的副作用是像标准输出流打印）。带有副作用的函数的标志性特征是结果类型为 Unit。如果一个函数不返回任何有意义的值，也就是 Unit 这样的结果类型所表达的意思，那么这个函数存在于世上唯一的意义就是产生某种副作用。
   
   #+begin_src scala
     def formatArgs(args: Array[String]) = args.mkString("\n")
   #+end_src

   #+RESULTS:
   : formatArgs: (args: Array[String])String

   scala 是指令式/函数式混合（hybrid）编程语言，你会发现有些场景下对于要解决的问题而言指令式更为合适，这个时候不要犹豫，使用指令式的风格就好。

* 第四章 类和对象
** 类，字段和方法
   #+begin_src scala
     class ChecksumAccumulator{
       // 这里是类定义
     }
   #+end_src
   在类定义中，你会填入字段（field）和方法（method），这些被统称为成员（member）。字段保留了对象的状态，或者说数据，而方法用这些数据来对对象执行计算。
   
   字段又叫做实例变量（instance variable），因为每个实例都有自己的变量。

   追求健壮性的一个重要手段是确保对象的状态（它的实例变量的值）在其整个声明周期都是有效的。首先是通过将字段标记为私有（private）来防止外部直接访问字段。在 Scala 中，使得成员允许公共访问（public）的方式是不再成员前面显示地给出任何访问修饰符。

   Scala 方法参数的一个重要特征是它们都是 val 而不是 var。所有方法都是，不光是类中的方法。

   在没有任何显示的 return 语句时，Scala 方法返回的是该方法计算出的最后一个（表达式的）值。实际上推荐的风格是避免使用任何显示的 return 语句，尤其是多个 return 语句。与此相反，尽量将每个方法当作是一个最终交出某个值的表达式。这样的哲学鼓励你编写短小的方法，将大的方法拆成小的。另一方面，设计中的选择也是取决于上下文的，Scala 也允许你方便地编写有多个显示 return 的方法，如果那确实是你想要的。

   #+begin_src scala
     class ChecksumAccumulator {
       private var sum = 0
       def add(b: Byte) = sum += b
       def checksum() = ~(sum & 0xFF) + 1
     }

     /** 虽然 Scala 能够正确推到出 add 和 checksum 这两个方法的结果类型，
     但是代码的读者需要在脑海里推断（mentally infer）这些结果类型。
     所以，通常更好的做法是对类中声明为公有的方法显示地给出结果类型。
     ,**/

     class ChecksumAccumulator {
       private var sum = 0
       def add(b: Byte): Unit = {sum += b}
       def checksum(): Int = ~(sum & 0xFF) + 1
     }
   #+end_src

   #+RESULTS:
   : defined class ChecksumAccumulator
   : defined class ChecksumAccumulator
   
   结果类型为 Unit 的方法， 如 add 方法，执行的目的是为了它们的副作用。副作用通常来说指的是改变方法外部的某种状态或执行 I/O 的动作。就 add 而言，其副作用就是给 sum 重新赋值。

   那些仅仅因为其副作用而被执行的方法被称作过程（procedure）。

** 分号推断
   在 Scala 程序中，每条语句最后的分号通常是可选的。如果想要一条跨多行的语句，大多数情况下直接换行即可，比如：if-else。不过偶尔 Scala 也会背离你的意图，在不该断句的地方断句：
   #+begin_src scala
     x
     + y
   #+end_src
   
   这段代码会被解析成 x 和 +y。解决办法，当用中缀（infix）操作符比如 + 来串接表达式时，一个常见的 Scala 风格是将操作符放在行尾而不是行首：
   #+begin_src scala
     x +
     y +
     z
   #+end_src

   分号推理规则：

   概括的说，除非以下任何一条为 true，代码行的末尾就会被当作分号处理：

   1. 当前行以一个不能作为语句结尾的词结尾，比如英文句点或中缀操作符。

   2. 下一行以一个不能作为语句开头的词开头

   3. 当前行的行尾出现在圆括号（...）或方括号 [...] 内，因为再怎么说圆括号和方括号也不能（直接）包含多条语句。

** 单例对象
   Scala 比 Java 更面向对象一点，是 Scala 的类不允许有静态（static）成员。对此类使用场景，Scala 提供了单例对象（singleton object）。单例对象的定义看上去跟类定义很像，只不过 class 关键字被换成了 object 关键字。

   当单例对象跟某个类公用同一个名字是，它被称作这个类的伴生对象（companion object）。必须在同一个源文件中定义类和类的伴生对象。同时，类又叫作这个单例对象的伴生类（companion class）。类和它的伴生对象可以互相访问对方的私有成员。
   #+begin_src scala
     import scala.collection.mutable
     object ChecksumAccumulator {
       private val cache = mutable.Map.empty[String, Int]
       def calculate(s: String): Int =
         if (cache.contains(s))
           cache(s)
         else {
           val acc = new ChecksumAccumulator
           for(c <- s)
             acc.add(c.toByte)
           val cs = acc.checksum()
           cache += (s -> cs)
           cs
         }
     }

     class ChecksumAccumulator {
       private var sum = 0
       def add(b: Byte): Unit = {sum += b}
       def checksum(): Int = ~(sum & 0xFF) + 1
     }
   #+end_src

   单例对象并不仅仅是用来存放静态方法，它是一等的对象。意味着：可以被存入变数或其他结构；可以被作为参数传递给其他函数；可以被作为函数的返回值；可以在执行期创造，而无需完全在设计期全部写出；即使没有被系结至某以名称，也可以存在。

   定义单例对象并不会定义类型（在 Scala 的抽象层级上是这样）。

   类和单例对象的一个区别是单例对象不能接收参数，而类可以。每个单例对象都是通过一个静态变量引用合成类（synthetic class）的实例来实现的，因此单例对象从初始化的语义上跟 Java 的静态成员是一致的。尤其体现在，单例对象在有代码访问时才被初始化。

   没有同名的伴生类的单例对象称为孤立对象（standalone object）。
** Scala 应用程序
   要运行一个 Scala 程序，必须提供一个独立对象的名称。这个独立对象需要包含一个 main 方法，该方法接收一个 Array[String] 作为参数，结果类型为 Unit。任何带有满足正确签名的 main 方法的独立对象都能被用作应用程序的入口。
   
   Scala 在每一个 Scala 源码文件中都隐式地引入了 java.lang 和 scala 包的成员，以及名为 Predef 的单例对象的所有成员。
   
   Scala 和 Java 的区别之一，是 Java 要求你将公共的类放入跟类同名的文件中，而在 Scala 中可以任意命名 .scala 文件，不论你放什么类或代码到这个文件中。不过，通常对于那些非脚本的场景，把类放入以类名命名的文件是推荐的做法，就像 Java 那样。 

** App 特质

   Scala 提供了一个特质 scala.App，帮助你节省敲键盘的动作。
   
   #+begin_src scala
     object summer extends App {
       println("extend App")
     }

   #+end_src

   #+RESULTS:
   : defined object summer

   要使用这个特质，首先要在你的单例对象名后加上 "extends App"。然后，并不是直接编写 main 方法，而是将你打算放在 main 方法里的代码直接写在单例对象的花括号中。可以通过名为 args 的字符串数组来访问命令行参数。

* 第五章 基础类型和操作
** 一些基础类型
   Byte，Short，Int，Long 和 Char 类型统称为整数类型（integral type）。整数类型加上 Float 和 Double 称作数值类型（numeric types）。
   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/基础类型取值区间.png]]

   Scala 的基础类型跟 Java 中对应的类型取值区间完全相同，这使得 Scala 编译器可以在产出的字节码中将 Scala 的值类型（value types）转换成 Java 的基本类型（primitive type）。

** 字面量
   用于 Int，Long，Short 和 Byte 的整数字面量有两种形式：十进制的和十六进制的。如果是以 0x 或 0X 开头，意味着这是十六进制的数。如果字面量以非 0 的数字打头，且除此之外没有其他修饰，那么它就是十进制的。

   如果整数字面量以 L 或 l 结尾，那么它就是 Long 型的，否则就是 Int。

   如果一个 Int 型的字面量被赋值给一个类型为 Short 或 Byte 的变量，该字面量会被当作 Short 或 Byte 类型，只要这个字面量的值在对应类型的合法取值区间即可。

   #+begin_src scala
     val hex = 0x5
     val hex2 = 0x00FF
     val magic = 0xcafebabe

     val dec1 = 31
     val dec2 = 255
     val dec3 = 20

     val prog = 0XCAFEBABEL
     val tower = 35L
     val of = 311

     val little: Short = 367
     val littler: Byte = 38 
   #+end_src

   #+RESULTS:
   #+begin_example
   hex: Int = 5
   hex2: Int = 255
   magic: Int = -889275714
   dec1: Int = 31
   dec2: Int = 255
   dec3: Int = 20
   prog: Long = 3405691582
   tower: Long = 35
   of: Int = 311
   little: Short = 367
   littler: Byte = 38
   #+end_example

*** 浮点数字面量
   浮点数字面量由十进制的数字，可选的小数点（decimal point），以及后续一个可选的 E 或 e 打头的指数（exponent）组成。指数部分指的是对前一部分乘以 10 的多少次方。如果浮点数字面量以 F 或 f 结尾，那它就是 Float 型的；否则它就是 Double。Double 型的浮点数字面量也可以以 D 或 d 结尾，但这是可选的。
   
   #+begin_src scala
     val big = 1.2345
     val bigger = 1.2345e1
     val biggerStill = 123E45
   #+end_src

   #+RESULTS:
   : big: Double = 1.2345
   : bigger: Double = 12.345
   : biggerStill: Double = 1.23E47

  
*** 字符字面量
   字符字面量（character literal）由一对单引号和中间的任意 Unicode 字符组成。
   
   #+begin_src scala
   val a = 'A'
   #+end_src

   #+RESULTS:
   : a: Char = A

   除了显示地给出原字符，也可以用字符的 Unicode 码来表示。具体写法是 \u 加上 Unicode 码对应的四位的十六进制数字，如：

   #+begin_src scala
   val d = '\u0041'
   val f = '\u0044'
   #+end_src

   #+RESULTS:
   : d: Char = A
   : f: Char = D

   事实上，这样的 Unicode 字符可以出现在 Scala 程序的任何位置。比如说，可以像这样命名一个标示符（变量）：
   
   #+begin_src scala
   val B\u0041\u0044 = 1
   #+end_src

   #+RESULTS:
   : BAD: Int = 1

   通常来说，把标识符命名成这样并不好，因为不易读。这样的语法规则存在，本意上让包含非 ASCII 的 Unicode 字符的 Scala 源文件可以用 ASCII 表示。

   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/特殊字符转义序列.png]]


*** 字符串字面量
   字符串字面量由双引号包起来的字符组成。
   
   #+begin_src scala
   val hello = "hello"
   val escapes = "\\\"\'"
   #+end_src

   #+RESULTS:
   : hello: String = hello
   : escapes: String = \"'

   由于这个语法对那些包含大量转义序列或者跨多行的字符串而言比较别扭，Scala 支持一种特殊的语法来表示原声字符串（raw string）。可以用三个双引号（"""）开始并以三个双引号结束来表示原声字符串。
   
   #+begin_src scala
   println("""Welcome to Ultamix 3000.
              Type "HELP" for help.""")
   #+end_src

   #+RESULTS:
   : Welcome to Ultamix 3000.
   :            Type "HELP" for help.

   这里的问题是字符串第二行前面的空格被包含在了字符串里！为了处理这个常见的情况，可以对字符串调用 stripMargin 方法。具体做法是在每一行开始加一个管道符号（|），然后对真个字符串调用 StripMargin：
   
   #+begin_src scala
   println("""Welcome to Ultamix 3000.
              |Type "HELP" for help.""")
   #+end_src

   #+RESULTS:
   : Welcome to Ultamix 3000.
   : Type "HELP" for help.

*** 符号字面量
   符号字面量（symbol literal）的写法是 'ident，其中 ident 可以是任何由字母和数字组成的标识符。这样的字面量会被映射成 scala.Symbol 这个预定义类的实例。确切地说，字面量 'cymbal 会被编译器展开成一个工厂方法的调用：Symbol("cymbal")。
   #+begin_src scala
     def updateRecordByName(r: Symbol, value: Any) = {
       // 具体代码
     }
   #+end_src

   #+RESULTS:
   : updateRecordByName: (r: Symbol, value: Any)Unit

   对于符号，你能做的不多，除了获取它的名称：
   
   #+begin_src scala
     val s = 'aSymbol
     val nm = s.name
   #+end_src

   #+RESULTS:
   : s: Symbol = 'aSymbol
   : nm: String = aSymbol

   另一个值得注意的点是符号会被内部化。如果同样的符号字面量出现两次，这两次引用都会指向同一个 Symbol 对象。

*** 布尔值字面量
   类型 Boolean 有两个字面量，true 和 false。

** 字符串插值
   Scala 包括了一个灵活的机制来支持字符串插值，允许你在字符串字面量中嵌入表达式。
   
   #+begin_src scala
   val name = "reader"
   println(s"Hello, $name!")
   #+end_src

   #+RESULTS:
   : name: String = reader
   : Hello, reader!

   表达式 s"Hello, $name!" 是一个被处理的（processed）字符串字面量。
   
   s插值器会对内嵌的每个表达式求值，对求值结果调用 toString，替换掉字面量中的那些表达式。

   可以随时使用美元符（$）开始一个表达式。如果表达式包含了非标识符字符，就必须将它放在花括号中，左花括号需要紧跟美元符。例如：

   #+begin_src scala
   s"The answer is ${6 * 7}."
   #+end_src

   #+RESULTS:
   : res73: String = The answer is 42.
   
   Scala 默认还提供了另外两种字符串插值器：raw 和 f。raw 字符串插值器的行为跟 s 类似，不过它并不识别字符转义序列。

   #+begin_src scala
   raw"No\\\\escape!"
   #+end_src

   #+RESULTS:
   : res75: String = No\\\\escape!

   f 字符串插值器允许你给内嵌的表达式加上 printf 风格的指令。需要将指令放在表达式后，以百分号（%）开始，使用 java.util.Formatter 中给出的语法。

   #+begin_src scala
   f"${math.Pi}%.5f"
   #+end_src

   #+RESULTS:
   : res77: String = 3.14159
   
   如果不对内嵌表达式给出任何格式化指令，f 字符串插值器将默认使用 %s，其含义是用 toString 的值来替换，就像 s 字符串插值器那样。

** 操作符即方法
   Int 包含了多个重载（overloaded）的 + 方法，分别接收不同的参数类型。
    
   在 Scala 中，操作符并不是特殊的语法，任何方法都可以是操作符。

   中缀操作符表示法意味着被调用的方法名位于对象和你想传入的参数中间。Scala 还提供了另外两种操作符表示法：前缀和后缀。跟中缀操作符表示法（操作符接收两个操作元，一个在左一个在右）不同。前缀和后缀操作符是一元的（unary）：它们只接收一个操作元。跟中缀操作符类似，这些前缀操作符也是调用方法的一种简写。不同的是，方法名称是“unary_”加上操作符。唯一能被用作前缀操作符的是 +，-，！和 ～。后缀操作符是哪些不接收参数并且调用时没有英文句点圆括号的方法。在 Scala 中，可以在方法调用时省去空的圆括号。从约定俗成的角度讲，如果方法有副作用的时候保留空的圆括号，比如 println()；而在方法没有副作用时则可以省掉这组圆括号。

   #+begin_src scala
     val sum = 1 + 2
     val sum = 1.+(2)
     val sum = 1 + 2L

     val s = "Hello, world!"
     s indexOf 'o'
     s indexOf ('o', 5)

     -2.0
       (2.0).unary_-

   #+end_src

   #+RESULTS:
   : sum: Int = 3
   : sum: Int = 3
   : sum: Long = 3
   : s: String = Hello, world!
   : res79: Int = 4
   : res80: Int = 8
   : res81: Double = -2.0
   : res82: Double = -2.0

** 算数操作
   当左右两个操作元都是整数类型（Int，Long，Byte，Short 或 Char）时，/ 操作符只会计算出商的整数部分。

** 关系和逻辑操作
   && 和 || 跟 Java 一样是短路的（short-circuit）
   
   既然操作符只是方法，短路是如何做到的。通常，所有入参都会在进入方法之前被求值，但是所有 Scala 方法都有一个机制来延迟对入参的求值，或者干脆不对他们求值。这个机制叫做传名参数（by-name parameter）。

** 位运算符
   位运算方法有：按位与（&），按位或（|）和按位异或（^）。一元的位补码操作（~，unary_~方法)对操作元的每一位取反。

   Scala 整数类型还提供了三个位移（shift）方法，左移（<< ）,右移（>>）和无符号右移（>>>）

** 对象相等性
   ==，！=
   
   这些操作际上可以被应用于所有的对象，并不仅仅是基础类型。
   
   #+begin_src scala
   List(1,2,3) == List(1,2,3)
   List(1,2,3) == List(4,5,6)
   #+end_src

   #+RESULTS:
   : res84: Boolean = true
   : res85: Boolean = false

   还可以比较不同类型的两个对象：
   
   #+begin_src scala
   1 == 1.0
   List(1, 2, 3) == "hello"
   #+end_src

   #+RESULTS:
   : res87: Boolean = true
   : res88: Boolean = false

   甚至可以拿对象跟 null 做比较，或者跟可能为 null 的对象做比较。不会抛出异常：
   
   #+begin_src scala
   List(1, 2, 3) == null
   null == List(1, 2, 3)
   #+end_src

   这背后的规则很简单：首先检查左侧是否为 null，如果不为 null，调用 equals 方法。

   这种比较逻辑对于不同的对象，只要它们的内容一致，且 equals 方法的实现也是完全基于内容的情况下，都会交出 true 答案。

   在 Java 中，可以用 == 来比较基本类型和引用类型。
   
   对于基本类型而言 Java 的 == 比较的是值的相等性，就跟 Scala 一样。

   但是对于引用类型，Java 的 == 比较的是引用相等性（reference equality），意思是两个变量指向 JVM 的堆上的同一个对象。Scala 也提供了用于比较引用相等性的机制，即名为 eq 的方法。

** 操作符优先级和结合性
   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/操作符优先级.png]]

** 富包装类
   每一个基础类型都有一个对应的富包装类，提供了额外的方法。
   
   #+ATTR_ORG: :width 500
   [[file:../../static/img/scala/富包装类.png]]


* 第六章 函数式对象
   本章的重点是那些定义函数式对象的类，或者那些没有任何可变状态的对象。

   通过实现一个有理数类来进行说明。

** 构建 Rational
   
   #+begin_src scala
   class Rational(n: Int, d: Int)
   #+end_src

   #+RESULTS:
   : defined class Rational

   如果一个类没有定义体，并不需要给出空的花括号（只要你想，当然也可以）。类名 Rational 后的圆括号中的标识 n 和 d 称作类参数（class parameter）。Scala 编译器将会采集到这两个类参数，并且创建一个主构造方法（primary constructor），接收同样的这两个参数。

   Scala 编译器会将你在类定义体中给出的非字段或方法定义的代码编译进类的主构造方法中。
   
   #+begin_src scala
   class Rational(n:Int, d: Int) {
     println("Created " + n + "/" + d)
   }
   new Rational(1, 2)
   #+end_src

   #+RESULTS:
   : defined class Rational
   : Created 1/2
   : res92: Rational = Rational@6519cd8a

   跟可变对象相比，不可变对象具有若干优势和一个潜在的劣势。首先，不可变对象通常比可变对象更容易推理。其次，可以相当自由地传递不可变对象，而对于可变对象，在传递给其他代码之前，你可能需要对它们做保护式的拷贝。再次，假如有两个并发的线程同时访问某个不可变对象，它们没有机会在对象正确构造以后破坏其状态，因为没有线程可以改变某个不可变对象的状态。最后，不可变对象可以安全地用作哈希表里的键。

   不可变对象的主要劣势是它们有时候会需要拷贝一个大的对象图，而实际上也许一个局部的更新也能满足要求。在某些场景下，不可变对象可能用起来比较别扭，同时还带来性能瓶颈。因此，类库对于不可变的类也提供可变的版本这样的做法并不罕见。例如： StringBuilder 类就是对不可变的 String 类的一个可变的替代。

** 重新实现 toString 方法
   解释器是通过对 Rational 对象调用 toString 来获取到这个看上去有点奇怪的字符串的。Rational 类默认继承了 java.lang.Object 类的 toString 实现。可以通过给 Rational 类添加 toString 方法来重写（override）默认的实现。
   
   #+begin_src scala
   class Rational(n: Int, d: Int) {
     override def toString = n + "/" + d
   }
   new Rational(1, 2)
   #+end_src

   #+RESULTS:
   : defined class Rational
   : a: Rational = 1/2
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evaluWzmTQ:17: error: value n is not a member of Rational
   :        a.n
   :          ^

** 检查前置条件
   面向对象编程的一个好处是可以将数据封装在对象里，以确保整个生命周期中数据都是合法的。对于 Rational 这样的不可变对象而言，这意味着需要确保对象在构造时数据合法。由于对 Rational 数来说分母为 0 是非法的状态，当 0 作为参数 d 传入的时候，不应该允许这样的 Rational 被创建出来。

   解决这个问题的最佳方式是对主构造方法定义一个前置条件（precondition），d 必须为非 0 值。前置条件是对传入方法或构造方法的值的约束，这是方法调用者必须满足的。实现这个的一种方式是用 require。

   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       override def toString = n + "/" + d
     }
     new Rational(1,2)
     new Rational(5,0)
   #+end_src

   #+RESULTS:
   : defined class Rational
   : res96: Rational = 1/2
   : java.lang.IllegalArgumentException: requirement failed
   :   at scala.Predef$.require(Predef.scala:212)
   :   ... 60 elided

** 添加字段
   #+begin_src scala
     class Rational(n: Int, b: Int) {
       require(d != 0)
       override def toString = n + "/" + d
       def add(r: Rational): Rational =
         new Rational(n * r.d + r.n * d, d * r.d)
     }
   #+end_src

   #+RESULTS:
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalGh7WdJ:21: error: value d is not a member of Rational
   :            new Rational(n * that.d + that.n * d, d * that.d)
   :                                  ^
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalGh7WdJ:21: error: value n is not a member of Rational
   :            new Rational(n * that.d + that.n * d, d * that.d)
   :                                           ^
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evalGh7WdJ:21: error: value d is not a member of Rational
   :            new Rational(n * that.d + that.n * d, d * that.d)
   :                                                           ^
   
   这段代码编译器回报错：

   虽然类参数 n 和 d 在你的 add 方法的作用域内，只能访问执行 add 调用的那个对象上的 n 和 d 的值。 因此，当你在 add 实现中用到 n 和 d 时，编译器会提供这些类参数对应的值，但它并不允许使用 that.n 或 that.d，因为 that 并非指向你执行 add 调用的那个对象。要访问 that 的分子和分母，需要将他们做成字符。

   #+begin_src scala
     class Rational(n: Int, d: Int) {
       override def toString = n + "/" + d
     }
     val r = new Rational(1, 2)
     r.n
   #+end_src

   #+RESULTS:
   : defined class Rational
   : r: Rational = 1/2
   : /var/folders/cb/bmm_ystd1rsdg076ndl8wv580000gp/T/scala-evaltF9HIU:17: error: value n is not a member of Rational
   :        r.n
   :          ^

   可以看出 n 和 d 并不是字段，只是类参数，所以不能使用 that.n 或 that.d 来访问。
   
   下面这个版本能够编译通过。
   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       val numer: Int = n
       val denom: Int = d
       override def toString = numer + "/" + denom
       def add(that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
     }
   #+end_src

   #+RESULTS:
   : defined class Rational

** 自引用
   关键字 this 指向当前执行方法的调用对象，当用在构造方法里的时候，指向被构造的对象实例。
   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       val numer: Int = n
       val denom: Int = d
       override def toString = numer + "/" + denom
       def add(that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
       def lessThan(that: Rational) = this.numer * that.denom < that.numer * this.numer
       def max(that: Rational) = if(this.lessThan(that)) that else this
     }
   #+end_src

   #+RESULTS:
   : defined class Rational
   
   lessThan 里的的 this 可以省略只写 numer。这两种表示法是等效的。

   max 里第一个 this 是冗余的。但是第二个 this 是必须的。

** 辅助构造方法
   在 Scala 中， 主构造方法之外的构造方法称为辅助构造方法（auxiliary constructor）。

   在 Scala 中，每个辅助构造方法都必须首先调用同一个类的另一个构造方法。换句话说，Scala 每个辅助就构造方法的第一条语句都必须是这样的形式：this(...)。被调用的构造方法要么是主构造方法，要么是另一个出现在发起调用的构造方法之前的另一个辅助构造方法。这个规则的净效应是 Scala 的每个构造方法最终都会调用到该类的主构造方法。这样一来，主构造方法就是类的单一入口。
   #+begin_src scala
   class Rational(n: Int, d: Int) {
       require(d != 0)
       val numer: Int = n
       val denom: Int = d
       def this(n: Int) = this(n, 1)  // auxiliary constructor
       override def toString = numer + "/" + denom
       def add(that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
       def lessThan(that: Rational) = this.numer * that.denom < that.numer * this.numer
       def max(that: Rational) = if(this.lessThan(that)) that else this
     }
   #+end_src

   #+RESULTS:
   : defined class Rational

   为什么 Scala 的构造方法规则比 Java 更严格。在 Java 中，构造方法要么调用同一个类的另一个构造方法，要么直接调用超类的构造方法。而在 Scala 类中，只用主构造方法可以调用超类的构造方法。Scala 这个增强的限制实际上是一个设计的取舍，用来换取更精简的代码和跟 Java 相比更为简单的构造方法。

** 私有字段和方法
   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       private val g = gcd(n.abs, d.abs)
       val numer: Int = n / g
       val denom: Int = d / g
       def this(n: Int) = this(n, 1)  // auxiliary constructor
       override def toString = numer + "/" + denom
       def add(that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
       def lessThan(that: Rational) = this.numer * that.denom < that.numer * this.numer
       def max(that: Rational) = if(this.lessThan(that)) that else this
       private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b )
       }

   #+end_src

   #+RESULTS:
   : defined class Rational

** 定义操作符   
   #+begin_src scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       private val g = gcd(n.abs, d.abs)
       val numer: Int = n / g
       val denom: Int = d / g
       def this(n: Int) = this(n, 1)  // auxiliary constructor
       override def toString = numer + "/" + denom
       def + (that: Rational): Rational = new Rational(numer * that.denom + that.numer *  denom, denom * that.denom)
       def * (that: Rational): Rational = new Rational(numer * that.numer, denom * that.numer)
       def lessThan(that: Rational) = this.numer * that.denom < that.numer * this.numer
       def max(that: Rational) = if(this.lessThan(that)) that else this
       private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b )
     }
   #+end_src

   #+RESULTS:
   : defined class Rational

   
** Scala 中的标识符
   Scala 遵循了 Java 的驼峰命名法（camel-case）命名标识符的传统。一个原因是跟 Java 保持一致，另一个原因是下划线在 Scala 代码中还有许多其他非标识符的用法。字段，方法参数，局部变量和函数的驼峰命名应该以小写字母打头，类和特质的驼峰命名应该以大写字母打头。

   在常量命名上， Scala 的习惯与 Java 不同。在 Scala 中，常量（constant）这个词并不意味着 val。虽然 val 在初始化之后确实不会变，但它仍然是个变量。举个例子来说，方法参数是 val，但方法每次别调用是，这些 val 都可以拿到不一样的值。而一个常量更永固。Java 对常量的命名习惯是全大写，并用下划线分隔开不同的单词，比如 MAX_VALUE 或 PI。而 Scala 的命名习惯只要求首字母大写。

   操作表示符（operator identifier）：略

   混合标识符（mixed identifier）由一个字母数字组合操作符，一个下划线和一个符号操作符组成。例如：unary_+

   字面标识符（literal identifier）是用反引号括起来的任意字符串。略


** 方法重载
   Scala 解析重载方法的过程跟 Java 很像。在每个具体的案例中，被选中的是那个最匹配入参静态类型的重载版本。

** 隐式转换
   如何写成 2 * r。解决办法：可以创建一个隐式转换（implicit conversion）。在需要时自动将整数转换成有理数。为了让隐式转换能工作，它需要在作用域内。如果你将隐士方法的定义放在 Rational 类内部，对解释器而言它是没有在作用域的。

* 第七章 内建的控制结构
  你会注意到一点，那就是 Scala 所有的控制结构都返回某种值作为结果。
